package repository

import (
	"database/sql"
	"embed"
	"fmt"
	"io/fs"
	"sort"
	"time"

	"github.com/rs/zerolog/log"
)

// MapFS est un wrapper qui "ment" à Goose en lui faisant croire
// que tous les fichiers sont au même niveau.
type MapFS struct {
	src     embed.FS
	folders []string
}

func NewMapFS(src embed.FS, folders []string) *MapFS {
	return &MapFS{
		src:     src,
		folders: folders,
	}
}

// FIX: Ajouter cette méthode Stat pour que Goose valide l'existence du dossier "."
func (m *MapFS) Stat(name string) (fs.FileInfo, error) {
	if name == "." || name == "/" {
		// On simule un répertoire racine
		return &MockDirInfo{name: name}, nil
	}
	// Pour les fichiers individuels, on délègue au système source
	for _, dir := range m.folders {
		if info, err := fs.Stat(m.src, dir+"/"+name); err == nil {
			return info, nil
		}
	}
	return nil, fs.ErrNotExist
}

func (m *MapFS) ReadDir(name string) ([]fs.DirEntry, error) {
	var allEntries []fs.DirEntry
	for _, dir := range m.folders {
		entries, _ := m.src.ReadDir(dir)
		allEntries = append(allEntries, entries...)
	}
	// C'est ICI que l'ordre global par timestamp se crée !
	sort.Slice(allEntries, func(i, j int) bool {
		return allEntries[i].Name() < allEntries[j].Name()
	})
	return allEntries, nil
}

func (m *MapFS) Open(name string) (fs.File, error) {
	// On cherche le fichier dans chaque dossier jusqu'à le trouver
	for _, dir := range m.folders {
		f, err := m.src.Open(dir + "/" + name)
		if err == nil {
			return f, nil
		}
	}
	return nil, fs.ErrNotExist
}

// Structure auxiliaire pour simuler les infos du répertoire racine
type MockDirInfo struct {
	name string
}

func (m *MockDirInfo) Name() string       { return m.name }
func (m *MockDirInfo) Size() int64        { return 0 }
func (m *MockDirInfo) Mode() fs.FileMode  { return fs.ModeDir }
func (m *MockDirInfo) ModTime() time.Time { return time.Now() }
func (m *MockDirInfo) IsDir() bool        { return true }
func (m *MockDirInfo) Sys() interface{}   { return nil }

func MigrateFromGoMigrateToGoose(db *sql.DB, versions []int64) error {
	// Check if core_migrations (go-migrate) exists and goose_db_version does not
	var needsMigration bool
	err := db.QueryRow(`
		SELECT 
			EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'core_migrations')
			AND
			NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'goose_db_version')
	`).Scan(&needsMigration)
	if err != nil {
		return fmt.Errorf("failed to check migration state: %w", err)
	}

	if !needsMigration {
		log.Info().Msg("Migration to goose not needed, skipping")
		return nil
	}

	log.Info().Msg("Detected go-migrate -> goose migration needed, running...")
	tx, err := db.Begin()
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback()

	// Create goose_db_version table
	_, err = tx.Exec(`
		CREATE TABLE goose_db_version (
			id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
			version_id int8 NOT NULL,
			is_applied bool NOT NULL,
			tstamp timestamp DEFAULT now() NOT NULL,
			CONSTRAINT goose_db_version_pkey PRIMARY KEY (id)
		);
	`)
	if err != nil {
		return fmt.Errorf("failed to create goose_db_version: %w", err)
	}

	for _, v := range versions {
		_, err = tx.Exec(`
			INSERT INTO goose_db_version (version_id, is_applied) VALUES ($1, true)
		`, v)
		if err != nil {
			return fmt.Errorf("failed to insert version %d: %w", v, err)
		}
	}

	// Drop the old go-migrate table
	_, err = tx.Exec(`DROP TABLE core_migrations`)
	if err != nil {
		return fmt.Errorf("failed to drop core_migrations: %w", err)
	}

	if err := tx.Commit(); err != nil {
		return fmt.Errorf("failed to commit migration to goose: %w", err)
	}

	log.Info().Msg("Successfully migrated from go-migrate to goose")
	return nil
}
