// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user_isolated.sql

package repository

import (
	"context"

	subentity "ctoup.com/coreapp/pkg/shared/repository/subentity"
)

const createUserByTenant = `-- name: CreateUserByTenant :one
INSERT INTO core_users (
  "id", "email", "profile", roles, "tenant_id"
) VALUES (
  $1, $3::text, $2, $4::VARCHAR[], $5::text
)
RETURNING id, profile, email, created_at, tenant_id, roles
`

type CreateUserByTenantParams struct {
	ID       string                `json:"id"`
	Profile  subentity.UserProfile `json:"profile"`
	Email    string                `json:"email"`
	Roles    []string              `json:"roles"`
	TenantID string                `json:"tenant_id"`
}

func (q *Queries) CreateUserByTenant(ctx context.Context, arg CreateUserByTenantParams) (CoreUser, error) {
	row := q.db.QueryRow(ctx, createUserByTenant,
		arg.ID,
		arg.Profile,
		arg.Email,
		arg.Roles,
		arg.TenantID,
	)
	var i CoreUser
	err := row.Scan(
		&i.ID,
		&i.Profile,
		&i.Email,
		&i.CreatedAt,
		&i.TenantID,
		&i.Roles,
	)
	return i, err
}

const deleteUserByTenant = `-- name: DeleteUserByTenant :one
DELETE FROM core_users
WHERE id = $1
AND tenant_id = $2::text
RETURNING id
`

type DeleteUserByTenantParams struct {
	ID       string `json:"id"`
	TenantID string `json:"tenant_id"`
}

func (q *Queries) DeleteUserByTenant(ctx context.Context, arg DeleteUserByTenantParams) (string, error) {
	row := q.db.QueryRow(ctx, deleteUserByTenant, arg.ID, arg.TenantID)
	var id string
	err := row.Scan(&id)
	return id, err
}

const getUserByTenantByEmail = `-- name: GetUserByTenantByEmail :one
SELECT id, profile, email, created_at, tenant_id, roles FROM core_users
WHERE email = $1::text
AND tenant_id = $2::text
LIMIT 1
`

type GetUserByTenantByEmailParams struct {
	Email    string `json:"email"`
	TenantID string `json:"tenant_id"`
}

func (q *Queries) GetUserByTenantByEmail(ctx context.Context, arg GetUserByTenantByEmailParams) (CoreUser, error) {
	row := q.db.QueryRow(ctx, getUserByTenantByEmail, arg.Email, arg.TenantID)
	var i CoreUser
	err := row.Scan(
		&i.ID,
		&i.Profile,
		&i.Email,
		&i.CreatedAt,
		&i.TenantID,
		&i.Roles,
	)
	return i, err
}

const getUserByTenantByID = `-- name: GetUserByTenantByID :one
SELECT id, profile, email, created_at, tenant_id, roles FROM core_users
WHERE id = $1
AND tenant_id = $2::text
LIMIT 1
`

type GetUserByTenantByIDParams struct {
	ID       string `json:"id"`
	TenantID string `json:"tenant_id"`
}

func (q *Queries) GetUserByTenantByID(ctx context.Context, arg GetUserByTenantByIDParams) (CoreUser, error) {
	row := q.db.QueryRow(ctx, getUserByTenantByID, arg.ID, arg.TenantID)
	var i CoreUser
	err := row.Scan(
		&i.ID,
		&i.Profile,
		&i.Email,
		&i.CreatedAt,
		&i.TenantID,
		&i.Roles,
	)
	return i, err
}

const listUsersByTenant = `-- name: ListUsersByTenant :many
SELECT id, profile, email, created_at, tenant_id, roles FROM core_users
WHERE (UPPER(email) LIKE UPPER($3) OR $3 IS NULL)
AND tenant_id = $4::text
ORDER BY created_at
LIMIT $1
OFFSET $2
`

type ListUsersByTenantParams struct {
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
	Like     interface{} `json:"like"`
	TenantID string      `json:"tenant_id"`
}

func (q *Queries) ListUsersByTenant(ctx context.Context, arg ListUsersByTenantParams) ([]CoreUser, error) {
	rows, err := q.db.Query(ctx, listUsersByTenant,
		arg.Limit,
		arg.Offset,
		arg.Like,
		arg.TenantID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CoreUser{}
	for rows.Next() {
		var i CoreUser
		if err := rows.Scan(
			&i.ID,
			&i.Profile,
			&i.Email,
			&i.CreatedAt,
			&i.TenantID,
			&i.Roles,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProfileByTenant = `-- name: UpdateProfileByTenant :one
UPDATE core_users 
SET profile = $1
WHERE id = $2
AND tenant_id = $3::text
RETURNING id
`

type UpdateProfileByTenantParams struct {
	Profile  subentity.UserProfile `json:"profile"`
	ID       string                `json:"id"`
	TenantID string                `json:"tenant_id"`
}

func (q *Queries) UpdateProfileByTenant(ctx context.Context, arg UpdateProfileByTenantParams) (string, error) {
	row := q.db.QueryRow(ctx, updateProfileByTenant, arg.Profile, arg.ID, arg.TenantID)
	var id string
	err := row.Scan(&id)
	return id, err
}

const updateUserByTenant = `-- name: UpdateUserByTenant :one
UPDATE core_users 
SET 
    roles = $2::VARCHAR[],
    profile = jsonb_set(
        profile, 
        '{name}', 
        to_jsonb($3::text), 
        true
    )
WHERE id = $1
AND tenant_id = $4::text
RETURNING id
`

type UpdateUserByTenantParams struct {
	ID       string   `json:"id"`
	Roles    []string `json:"roles"`
	Name     string   `json:"name"`
	TenantID string   `json:"tenant_id"`
}

func (q *Queries) UpdateUserByTenant(ctx context.Context, arg UpdateUserByTenantParams) (string, error) {
	row := q.db.QueryRow(ctx, updateUserByTenant,
		arg.ID,
		arg.Roles,
		arg.Name,
		arg.TenantID,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}
