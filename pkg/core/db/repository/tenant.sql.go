// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tenant.sql

package repository

import (
	"context"

	subentity "ctoup.com/coreapp/pkg/shared/repository/subentity"
	"github.com/google/uuid"
)

const createTenant = `-- name: CreateTenant :one
INSERT INTO core_tenants (
  user_id, "tenant_id", "name", "subdomain", "enable_email_link_sign_in", "allow_password_sign_up", "allow_sign_up"
) VALUES (
  $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, tenant_id, name, subdomain, enable_email_link_sign_in, allow_password_sign_up, user_id, created_at, updated_at, profile, features, allow_sign_up
`

type CreateTenantParams struct {
	UserID                string `json:"user_id"`
	TenantID              string `json:"tenant_id"`
	Name                  string `json:"name"`
	Subdomain             string `json:"subdomain"`
	EnableEmailLinkSignIn bool   `json:"enable_email_link_sign_in"`
	AllowPasswordSignUp   bool   `json:"allow_password_sign_up"`
	AllowSignUp           bool   `json:"allow_sign_up"`
}

func (q *Queries) CreateTenant(ctx context.Context, arg CreateTenantParams) (CoreTenant, error) {
	row := q.db.QueryRow(ctx, createTenant,
		arg.UserID,
		arg.TenantID,
		arg.Name,
		arg.Subdomain,
		arg.EnableEmailLinkSignIn,
		arg.AllowPasswordSignUp,
		arg.AllowSignUp,
	)
	var i CoreTenant
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Subdomain,
		&i.EnableEmailLinkSignIn,
		&i.AllowPasswordSignUp,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Profile,
		&i.Features,
		&i.AllowSignUp,
	)
	return i, err
}

const deleteTenant = `-- name: DeleteTenant :one
DELETE FROM core_tenants
WHERE id = $1
RETURNING id
`

func (q *Queries) DeleteTenant(ctx context.Context, id uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, deleteTenant, id)
	err := row.Scan(&id)
	return id, err
}

const getTenantByID = `-- name: GetTenantByID :one
SELECT id, tenant_id, name, subdomain, enable_email_link_sign_in, allow_password_sign_up, user_id, created_at, updated_at, profile, features, allow_sign_up FROM core_tenants
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetTenantByID(ctx context.Context, id uuid.UUID) (CoreTenant, error) {
	row := q.db.QueryRow(ctx, getTenantByID, id)
	var i CoreTenant
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Subdomain,
		&i.EnableEmailLinkSignIn,
		&i.AllowPasswordSignUp,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Profile,
		&i.Features,
		&i.AllowSignUp,
	)
	return i, err
}

const getTenantBySubdomain = `-- name: GetTenantBySubdomain :one
SELECT id, tenant_id, name, subdomain, enable_email_link_sign_in, allow_password_sign_up, user_id, created_at, updated_at, profile, features, allow_sign_up FROM core_tenants
WHERE subdomain = $1 LIMIT 1
`

func (q *Queries) GetTenantBySubdomain(ctx context.Context, subdomain string) (CoreTenant, error) {
	row := q.db.QueryRow(ctx, getTenantBySubdomain, subdomain)
	var i CoreTenant
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Subdomain,
		&i.EnableEmailLinkSignIn,
		&i.AllowPasswordSignUp,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Profile,
		&i.Features,
		&i.AllowSignUp,
	)
	return i, err
}

const getTenantByTenantID = `-- name: GetTenantByTenantID :one
SELECT id, tenant_id, name, subdomain, enable_email_link_sign_in, allow_password_sign_up, user_id, created_at, updated_at, profile, features, allow_sign_up FROM core_tenants
WHERE tenant_id = $1 LIMIT 1
`

func (q *Queries) GetTenantByTenantID(ctx context.Context, tenantID string) (CoreTenant, error) {
	row := q.db.QueryRow(ctx, getTenantByTenantID, tenantID)
	var i CoreTenant
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Subdomain,
		&i.EnableEmailLinkSignIn,
		&i.AllowPasswordSignUp,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Profile,
		&i.Features,
		&i.AllowSignUp,
	)
	return i, err
}

const listTenants = `-- name: ListTenants :many
SELECT id, tenant_id, name, subdomain, enable_email_link_sign_in, allow_password_sign_up, user_id, created_at, updated_at, profile, features, allow_sign_up FROM core_tenants
WHERE (UPPER(name) LIKE UPPER($3) OR $3 IS NULL)
ORDER BY
  CASE
            WHEN $4::text = 'asc' and $5::text = 'tenant_id' THEN "tenant_id"
            WHEN $4::text = 'asc' and $5::text = 'name' THEN "name"
            WHEN $4::text = 'asc' and $5::text = 'subdomain' THEN "subdomain"
        END ASC,
  CASE
            WHEN (NOT $4::text = 'asc') and $5::text = 'tenant_id' THEN "tenant_id"
            WHEN (NOT $4::text = 'asc') and $5::text = 'name' THEN "name"
            WHEN (NOT $4::text = 'asc') and $5::text = 'subdomain' THEN "subdomain"
        END DESC
LIMIT $1
OFFSET $2
`

type ListTenantsParams struct {
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
	Like   interface{} `json:"like"`
	Order  string      `json:"order"`
	SortBy string      `json:"sortBy"`
}

func (q *Queries) ListTenants(ctx context.Context, arg ListTenantsParams) ([]CoreTenant, error) {
	rows, err := q.db.Query(ctx, listTenants,
		arg.Limit,
		arg.Offset,
		arg.Like,
		arg.Order,
		arg.SortBy,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CoreTenant{}
	for rows.Next() {
		var i CoreTenant
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.Subdomain,
			&i.EnableEmailLinkSignIn,
			&i.AllowPasswordSignUp,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Profile,
			&i.Features,
			&i.AllowSignUp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTenant = `-- name: UpdateTenant :one
UPDATE core_tenants 
SET 
    "name" = $2,
    "subdomain" = $3,
    "enable_email_link_sign_in" = $4,
    "allow_password_sign_up" = $5,
    "allow_sign_up" = $6
WHERE id = $1
RETURNING id
`

type UpdateTenantParams struct {
	ID                    uuid.UUID `json:"id"`
	Name                  string    `json:"name"`
	Subdomain             string    `json:"subdomain"`
	EnableEmailLinkSignIn bool      `json:"enable_email_link_sign_in"`
	AllowPasswordSignUp   bool      `json:"allow_password_sign_up"`
	AllowSignUp           bool      `json:"allow_sign_up"`
}

func (q *Queries) UpdateTenant(ctx context.Context, arg UpdateTenantParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, updateTenant,
		arg.ID,
		arg.Name,
		arg.Subdomain,
		arg.EnableEmailLinkSignIn,
		arg.AllowPasswordSignUp,
		arg.AllowSignUp,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const updateTenantFeatures = `-- name: UpdateTenantFeatures :one
UPDATE core_tenants 
SET features = $1
WHERE id = $2
RETURNING id
`

type UpdateTenantFeaturesParams struct {
	Features subentity.TenantFeatures `json:"features"`
	ID       uuid.UUID                `json:"id"`
}

func (q *Queries) UpdateTenantFeatures(ctx context.Context, arg UpdateTenantFeaturesParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, updateTenantFeatures, arg.Features, arg.ID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const updateTenantProfile = `-- name: UpdateTenantProfile :one
UPDATE core_tenants 
SET profile = $1
WHERE tenant_id = $2::text
RETURNING id
`

type UpdateTenantProfileParams struct {
	Profile  subentity.TenantProfile `json:"profile"`
	TenantID string                  `json:"tenant_id"`
}

func (q *Queries) UpdateTenantProfile(ctx context.Context, arg UpdateTenantProfileParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, updateTenantProfile, arg.Profile, arg.TenantID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}
