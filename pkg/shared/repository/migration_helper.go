package repository

import (
	"database/sql"
	"embed"
	"fmt"
	"io/fs"
	"sort"
	"time"

	"github.com/rs/zerolog/log"
)

// MapFS is a custom implementation of fs.FS
// that allows us to treat multiple embedded folders as if they were one,
// ensuring that all migration files are read in a single pass and sorted by name,
// regardless of their original folder.
type MapFS struct {
	src     embed.FS
	folders []string
}

func NewMapFS(src embed.FS, folders []string) *MapFS {
	return &MapFS{
		src:     src,
		folders: folders,
	}
}

// FIX: Stat for Goose to valid validate "."
func (m *MapFS) Stat(name string) (fs.FileInfo, error) {
	if name == "." || name == "/" {
		// simulate a directory info for the root,
		// since we're treating multiple folders as one
		return &MockDirInfo{name: name}, nil
	}
	// For any other name,
	// we check each folder for the file and return its info if found
	for _, dir := range m.folders {
		if info, err := fs.Stat(m.src, dir+"/"+name); err == nil {
			return info, nil
		}
	}
	return nil, fs.ErrNotExist
}

func (m *MapFS) ReadDir(name string) ([]fs.DirEntry, error) {
	var allEntries []fs.DirEntry
	for _, dir := range m.folders {
		entries, _ := m.src.ReadDir(dir)
		allEntries = append(allEntries, entries...)
	}
	// Sort all entries by name to ensure correct migration order
	sort.Slice(allEntries, func(i, j int) bool {
		return allEntries[i].Name() < allEntries[j].Name()
	})
	return allEntries, nil
}

func (m *MapFS) Open(name string) (fs.File, error) {
	// Search for the file in each folder and return it if found
	for _, dir := range m.folders {
		f, err := m.src.Open(dir + "/" + name)
		if err == nil {
			return f, nil
		}
	}
	return nil, fs.ErrNotExist
}

// Structure to simulate root directory info for MapFS,
// since we're treating multiple folders as one.
type MockDirInfo struct {
	name string
}

func (m *MockDirInfo) Name() string       { return m.name }
func (m *MockDirInfo) Size() int64        { return 0 }
func (m *MockDirInfo) Mode() fs.FileMode  { return fs.ModeDir }
func (m *MockDirInfo) ModTime() time.Time { return time.Now() }
func (m *MockDirInfo) IsDir() bool        { return true }
func (m *MockDirInfo) Sys() interface{}   { return nil }

func MigrateFromGoMigrateToGoose(db *sql.DB, versions []int64) error {
	// Check if core_migrations (go-migrate) exists and goose_db_version does not
	var needsMigration bool
	err := db.QueryRow(`
		SELECT 
			EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'core_migrations')
			AND
			NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'goose_db_version')
	`).Scan(&needsMigration)
	if err != nil {
		return fmt.Errorf("failed to check migration state: %w", err)
	}

	if !needsMigration {
		log.Info().Msg("Migration to goose not needed, skipping")
		return nil
	}

	log.Info().Msg("Detected go-migrate -> goose migration needed, running...")
	tx, err := db.Begin()
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback()

	// Create goose_db_version table
	_, err = tx.Exec(`
		CREATE TABLE goose_db_version (
			id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
			version_id int8 NOT NULL,
			is_applied bool NOT NULL,
			tstamp timestamp DEFAULT now() NOT NULL,
			CONSTRAINT goose_db_version_pkey PRIMARY KEY (id)
		);
	`)
	if err != nil {
		return fmt.Errorf("failed to create goose_db_version: %w", err)
	}

	for _, v := range versions {
		_, err = tx.Exec(`
			INSERT INTO goose_db_version (version_id, is_applied) VALUES ($1, true)
		`, v)
		if err != nil {
			return fmt.Errorf("failed to insert version %d: %w", v, err)
		}
	}

	// Drop the old go-migrate table
	_, err = tx.Exec(`DROP TABLE core_migrations`)
	if err != nil {
		return fmt.Errorf("failed to drop core_migrations: %w", err)
	}

	if err := tx.Commit(); err != nil {
		return fmt.Errorf("failed to commit migration to goose: %w", err)
	}

	log.Info().Msg("Successfully migrated from go-migrate to goose")
	return nil
}
