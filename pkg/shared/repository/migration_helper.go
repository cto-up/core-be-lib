package repository

import (
	"database/sql"
	"fmt"
	"io/fs"
	"sort"
	"strings"
	"time"

	"github.com/rs/zerolog/log"
)

// MapFS is a custom implementation of fs.FS
// that allows us to treat multiple embedded folders as if they were one,
// ensuring that all migration files are read in a single pass and sorted by name,
// regardless of their original folder.
type MapFS struct {
	sources []fs.FS
	files   map[string]fs.FS // filename -> owning FS
}

func NewMapFS(sources ...fs.FS) (*MapFS, error) {
	m := &MapFS{
		sources: sources,
		files:   make(map[string]fs.FS),
	}

	for idx, src := range sources {
		entries, err := fs.ReadDir(src, ".")
		if err != nil {
			log.Debug().
				Int("source_index", idx).
				Err(err).
				Msg("Migration FS skipped (unable to read root)")
			continue
		}

		for _, e := range entries {
			if e.IsDir() {
				continue
			}

			name := e.Name()

			// Collision detection
			if _, exists := m.files[name]; exists {
				return nil, fmt.Errorf(
					"migration filename conflict detected: %q exists in multiple modules",
					name,
				)
			}

			m.files[name] = src

			log.Debug().
				Str("migration", name).
				Int("source_index", idx).
				Msg("Registered migration file")
		}
	}

	if len(m.files) == 0 {
		log.Warn().Msg("No migration files registered in MapFS")
	}

	return m, nil
}

// FIX: Stat for Goose to valid validate "."
func (m *MapFS) Stat(name string) (fs.FileInfo, error) {
	if name == "." || name == "/" {
		return &MockDirInfo{name: name}, nil
	}

	if src, ok := m.files[name]; ok {
		return fs.Stat(src, name)
	}

	return nil, fs.ErrNotExist
}

func (m *MapFS) ReadDir(name string) ([]fs.DirEntry, error) {
	var entries []fs.DirEntry

	for filename, src := range m.files {
		info, err := fs.Stat(src, filename)
		if err != nil {
			continue
		}

		entries = append(entries, fs.FileInfoToDirEntry(info))
	}

	sort.Slice(entries, func(i, j int) bool {
		return entries[i].Name() < entries[j].Name()
	})

	log.Debug().
		Int("count", len(entries)).
		Str("files", strings.Join(func() []string {
			names := make([]string, 0, len(entries))
			for _, e := range entries {
				names = append(names, e.Name())
			}
			return names
		}(), ", ")).
		Msg("Resolved merged migration directory")

	return entries, nil
}

func (m *MapFS) Open(name string) (fs.File, error) {
	if src, ok := m.files[name]; ok {
		return src.Open(name)
	}
	return nil, fs.ErrNotExist
}

// Structure to simulate root directory info for MapFS,
// since we're treating multiple folders as one.
type MockDirInfo struct {
	name string
}

func (m *MockDirInfo) Name() string       { return m.name }
func (m *MockDirInfo) Size() int64        { return 0 }
func (m *MockDirInfo) Mode() fs.FileMode  { return fs.ModeDir }
func (m *MockDirInfo) ModTime() time.Time { return time.Now() }
func (m *MockDirInfo) IsDir() bool        { return true }
func (m *MockDirInfo) Sys() interface{}   { return nil }

func MigrateFromGoMigrateToGoose(db *sql.DB, versions []int64) error {
	// Check if core_migrations (go-migrate) exists and goose_db_version does not
	var needsMigration bool
	err := db.QueryRow(`
		SELECT 
			EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'core_migrations')
			AND
			NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'goose_db_version')
	`).Scan(&needsMigration)
	if err != nil {
		return fmt.Errorf("failed to check migration state: %w", err)
	}

	if !needsMigration {
		log.Info().Msg("Migration to goose not needed, skipping")
		return nil
	}

	log.Info().Msg("Detected go-migrate -> goose migration needed, running...")
	tx, err := db.Begin()
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback()

	// Create goose_db_version table
	_, err = tx.Exec(`
		CREATE TABLE goose_db_version (
			id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
			version_id int8 NOT NULL,
			is_applied bool NOT NULL,
			tstamp timestamp DEFAULT now() NOT NULL,
			CONSTRAINT goose_db_version_pkey PRIMARY KEY (id)
		);
	`)
	if err != nil {
		return fmt.Errorf("failed to create goose_db_version: %w", err)
	}

	for _, v := range versions {
		_, err = tx.Exec(`
			INSERT INTO goose_db_version (version_id, is_applied) VALUES ($1, true)
		`, v)
		if err != nil {
			return fmt.Errorf("failed to insert version %d: %w", v, err)
		}
	}

	// Drop the old go-migrate table
	_, err = tx.Exec(`DROP TABLE core_migrations`)
	if err != nil {
		return fmt.Errorf("failed to drop core_migrations: %w", err)
	}

	if err := tx.Commit(); err != nil {
		return fmt.Errorf("failed to commit migration to goose: %w", err)
	}

	log.Info().Msg("Successfully migrated from go-migrate to goose")
	return nil
}
