// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: api_token.sql

package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createAPIToken = `-- name: CreateAPIToken :one
INSERT INTO core_api_tokens (
  client_application_id, name, description, token_hash, token_prefix, 
  expires_at, created_by, scopes
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, client_application_id, name, description, token_hash, token_prefix, expires_at, revoked, revoked_at, revoked_reason, revoked_by, created_by, scopes, created_at, updated_at, last_used_at, last_used_ip
`

type CreateAPITokenParams struct {
	ClientApplicationID uuid.UUID   `json:"client_application_id"`
	Name                string      `json:"name"`
	Description         pgtype.Text `json:"description"`
	TokenHash           []byte      `json:"token_hash"`
	TokenPrefix         string      `json:"token_prefix"`
	ExpiresAt           time.Time   `json:"expires_at"`
	CreatedBy           string      `json:"created_by"`
	Scopes              []string    `json:"scopes"`
}

func (q *Queries) CreateAPIToken(ctx context.Context, arg CreateAPITokenParams) (CoreApiToken, error) {
	row := q.db.QueryRow(ctx, createAPIToken,
		arg.ClientApplicationID,
		arg.Name,
		arg.Description,
		arg.TokenHash,
		arg.TokenPrefix,
		arg.ExpiresAt,
		arg.CreatedBy,
		arg.Scopes,
	)
	var i CoreApiToken
	err := row.Scan(
		&i.ID,
		&i.ClientApplicationID,
		&i.Name,
		&i.Description,
		&i.TokenHash,
		&i.TokenPrefix,
		&i.ExpiresAt,
		&i.Revoked,
		&i.RevokedAt,
		&i.RevokedReason,
		&i.RevokedBy,
		&i.CreatedBy,
		&i.Scopes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsedAt,
		&i.LastUsedIp,
	)
	return i, err
}

const createAPITokenAuditLog = `-- name: CreateAPITokenAuditLog :one
INSERT INTO core_api_token_audit_logs (
  token_id, action, ip_address, user_agent, additional_data
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING id, token_id, action, ip_address, user_agent, timestamp, additional_data
`

type CreateAPITokenAuditLogParams struct {
	TokenID        uuid.UUID   `json:"token_id"`
	Action         string      `json:"action"`
	IpAddress      pgtype.Text `json:"ip_address"`
	UserAgent      pgtype.Text `json:"user_agent"`
	AdditionalData []byte      `json:"additional_data"`
}

func (q *Queries) CreateAPITokenAuditLog(ctx context.Context, arg CreateAPITokenAuditLogParams) (CoreApiTokenAuditLog, error) {
	row := q.db.QueryRow(ctx, createAPITokenAuditLog,
		arg.TokenID,
		arg.Action,
		arg.IpAddress,
		arg.UserAgent,
		arg.AdditionalData,
	)
	var i CoreApiTokenAuditLog
	err := row.Scan(
		&i.ID,
		&i.TokenID,
		&i.Action,
		&i.IpAddress,
		&i.UserAgent,
		&i.Timestamp,
		&i.AdditionalData,
	)
	return i, err
}

const deleteAPIToken = `-- name: DeleteAPIToken :one
DELETE FROM core_api_tokens
WHERE id = $1
RETURNING id
`

func (q *Queries) DeleteAPIToken(ctx context.Context, id uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, deleteAPIToken, id)
	err := row.Scan(&id)
	return id, err
}

const getAPITokenAuditLogs = `-- name: GetAPITokenAuditLogs :many
SELECT id, token_id, action, ip_address, user_agent, timestamp, additional_data FROM core_api_token_audit_logs
WHERE token_id = $1
ORDER BY timestamp DESC
LIMIT $2
OFFSET $3
`

type GetAPITokenAuditLogsParams struct {
	TokenID uuid.UUID `json:"token_id"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

func (q *Queries) GetAPITokenAuditLogs(ctx context.Context, arg GetAPITokenAuditLogsParams) ([]CoreApiTokenAuditLog, error) {
	rows, err := q.db.Query(ctx, getAPITokenAuditLogs, arg.TokenID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CoreApiTokenAuditLog{}
	for rows.Next() {
		var i CoreApiTokenAuditLog
		if err := rows.Scan(
			&i.ID,
			&i.TokenID,
			&i.Action,
			&i.IpAddress,
			&i.UserAgent,
			&i.Timestamp,
			&i.AdditionalData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAPITokenByHash = `-- name: GetAPITokenByHash :one
SELECT t.id, t.client_application_id, t.name, t.description, t.token_hash, t.token_prefix, t.expires_at, t.revoked, t.revoked_at, t.revoked_reason, t.revoked_by, t.created_by, t.scopes, t.created_at, t.updated_at, t.last_used_at, t.last_used_ip, c.tenant_id 
FROM core_api_tokens t
JOIN core_client_applications c ON t.client_application_id = c.id
WHERE t.token_hash = $1 
  AND t.revoked = false
  AND t.expires_at > NOW()
LIMIT 1
`

type GetAPITokenByHashRow struct {
	ID                  uuid.UUID          `json:"id"`
	ClientApplicationID uuid.UUID          `json:"client_application_id"`
	Name                string             `json:"name"`
	Description         pgtype.Text        `json:"description"`
	TokenHash           []byte             `json:"token_hash"`
	TokenPrefix         string             `json:"token_prefix"`
	ExpiresAt           time.Time          `json:"expires_at"`
	Revoked             bool               `json:"revoked"`
	RevokedAt           pgtype.Timestamptz `json:"revoked_at"`
	RevokedReason       pgtype.Text        `json:"revoked_reason"`
	RevokedBy           pgtype.Text        `json:"revoked_by"`
	CreatedBy           string             `json:"created_by"`
	Scopes              []string           `json:"scopes"`
	CreatedAt           time.Time          `json:"created_at"`
	UpdatedAt           time.Time          `json:"updated_at"`
	LastUsedAt          pgtype.Timestamptz `json:"last_used_at"`
	LastUsedIp          pgtype.Text        `json:"last_used_ip"`
	TenantID            pgtype.Text        `json:"tenant_id"`
}

func (q *Queries) GetAPITokenByHash(ctx context.Context, tokenHash []byte) (GetAPITokenByHashRow, error) {
	row := q.db.QueryRow(ctx, getAPITokenByHash, tokenHash)
	var i GetAPITokenByHashRow
	err := row.Scan(
		&i.ID,
		&i.ClientApplicationID,
		&i.Name,
		&i.Description,
		&i.TokenHash,
		&i.TokenPrefix,
		&i.ExpiresAt,
		&i.Revoked,
		&i.RevokedAt,
		&i.RevokedReason,
		&i.RevokedBy,
		&i.CreatedBy,
		&i.Scopes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsedAt,
		&i.LastUsedIp,
		&i.TenantID,
	)
	return i, err
}

const getAPITokenByID = `-- name: GetAPITokenByID :one
SELECT t.id, t.client_application_id, t.name, t.description, t.token_hash, t.token_prefix, t.expires_at, t.revoked, t.revoked_at, t.revoked_reason, t.revoked_by, t.created_by, t.scopes, t.created_at, t.updated_at, t.last_used_at, t.last_used_ip, c.tenant_id 
FROM core_api_tokens t
JOIN core_client_applications c ON t.client_application_id = c.id
WHERE t.id = $1 
  AND (c.tenant_id = $2::varchar OR c.tenant_id IS NULL)
  AND t.revoked = false
LIMIT 1
`

type GetAPITokenByIDParams struct {
	ID       uuid.UUID   `json:"id"`
	TenantID pgtype.Text `json:"tenant_id"`
}

type GetAPITokenByIDRow struct {
	ID                  uuid.UUID          `json:"id"`
	ClientApplicationID uuid.UUID          `json:"client_application_id"`
	Name                string             `json:"name"`
	Description         pgtype.Text        `json:"description"`
	TokenHash           []byte             `json:"token_hash"`
	TokenPrefix         string             `json:"token_prefix"`
	ExpiresAt           time.Time          `json:"expires_at"`
	Revoked             bool               `json:"revoked"`
	RevokedAt           pgtype.Timestamptz `json:"revoked_at"`
	RevokedReason       pgtype.Text        `json:"revoked_reason"`
	RevokedBy           pgtype.Text        `json:"revoked_by"`
	CreatedBy           string             `json:"created_by"`
	Scopes              []string           `json:"scopes"`
	CreatedAt           time.Time          `json:"created_at"`
	UpdatedAt           time.Time          `json:"updated_at"`
	LastUsedAt          pgtype.Timestamptz `json:"last_used_at"`
	LastUsedIp          pgtype.Text        `json:"last_used_ip"`
	TenantID            pgtype.Text        `json:"tenant_id"`
}

func (q *Queries) GetAPITokenByID(ctx context.Context, arg GetAPITokenByIDParams) (GetAPITokenByIDRow, error) {
	row := q.db.QueryRow(ctx, getAPITokenByID, arg.ID, arg.TenantID)
	var i GetAPITokenByIDRow
	err := row.Scan(
		&i.ID,
		&i.ClientApplicationID,
		&i.Name,
		&i.Description,
		&i.TokenHash,
		&i.TokenPrefix,
		&i.ExpiresAt,
		&i.Revoked,
		&i.RevokedAt,
		&i.RevokedReason,
		&i.RevokedBy,
		&i.CreatedBy,
		&i.Scopes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsedAt,
		&i.LastUsedIp,
		&i.TenantID,
	)
	return i, err
}

const listAPITokens = `-- name: ListAPITokens :many
SELECT t.id, t.client_application_id, t.name, t.description, t.token_hash, t.token_prefix, t.expires_at, t.revoked, t.revoked_at, t.revoked_reason, t.revoked_by, t.created_by, t.scopes, t.created_at, t.updated_at, t.last_used_at, t.last_used_ip, c.name as application_name 
FROM core_api_tokens t
JOIN core_client_applications c ON t.client_application_id = c.id
WHERE (c.tenant_id = $3::varchar OR c.tenant_id IS NULL)
  AND (t.client_application_id = $4::uuid OR $4 IS NULL)
  AND (
    $5::boolean OR t.revoked = false
  )
  AND (
    $6::boolean OR t.expires_at > NOW()
  )
  AND (
    UPPER(t.name) LIKE UPPER($7) 
    OR UPPER(c.name) LIKE UPPER($7)
    OR $7 IS NULL
  )
ORDER BY
  CASE WHEN $8::TEXT = 'name' AND $9::TEXT = 'asc' THEN t.name END ASC,
  CASE WHEN $8::TEXT = 'name' AND $9::TEXT != 'asc' THEN t.name END DESC,
  CASE WHEN $8::TEXT = 'created_at' AND $9::TEXT = 'asc' THEN t.created_at END ASC,
  CASE WHEN $8::TEXT = 'created_at' AND $9::TEXT != 'asc' THEN t.created_at END DESC,
  CASE WHEN $8::TEXT = 'expires_at' AND $9::TEXT = 'asc' THEN t.expires_at END ASC,
  CASE WHEN $8::TEXT = 'expires_at' AND $9::TEXT != 'asc' THEN t.expires_at END DESC
LIMIT $1
OFFSET $2
`

type ListAPITokensParams struct {
	Limit               int32       `json:"limit"`
	Offset              int32       `json:"offset"`
	TenantID            pgtype.Text `json:"tenant_id"`
	ClientApplicationID pgtype.UUID `json:"client_application_id"`
	IncludeRevoked      pgtype.Bool `json:"include_revoked"`
	IncludeExpired      pgtype.Bool `json:"include_expired"`
	Like                interface{} `json:"like"`
	SortBy              string      `json:"sort_by"`
	Order               string      `json:"order"`
}

type ListAPITokensRow struct {
	ID                  uuid.UUID          `json:"id"`
	ClientApplicationID uuid.UUID          `json:"client_application_id"`
	Name                string             `json:"name"`
	Description         pgtype.Text        `json:"description"`
	TokenHash           []byte             `json:"token_hash"`
	TokenPrefix         string             `json:"token_prefix"`
	ExpiresAt           time.Time          `json:"expires_at"`
	Revoked             bool               `json:"revoked"`
	RevokedAt           pgtype.Timestamptz `json:"revoked_at"`
	RevokedReason       pgtype.Text        `json:"revoked_reason"`
	RevokedBy           pgtype.Text        `json:"revoked_by"`
	CreatedBy           string             `json:"created_by"`
	Scopes              []string           `json:"scopes"`
	CreatedAt           time.Time          `json:"created_at"`
	UpdatedAt           time.Time          `json:"updated_at"`
	LastUsedAt          pgtype.Timestamptz `json:"last_used_at"`
	LastUsedIp          pgtype.Text        `json:"last_used_ip"`
	ApplicationName     string             `json:"application_name"`
}

func (q *Queries) ListAPITokens(ctx context.Context, arg ListAPITokensParams) ([]ListAPITokensRow, error) {
	rows, err := q.db.Query(ctx, listAPITokens,
		arg.Limit,
		arg.Offset,
		arg.TenantID,
		arg.ClientApplicationID,
		arg.IncludeRevoked,
		arg.IncludeExpired,
		arg.Like,
		arg.SortBy,
		arg.Order,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAPITokensRow{}
	for rows.Next() {
		var i ListAPITokensRow
		if err := rows.Scan(
			&i.ID,
			&i.ClientApplicationID,
			&i.Name,
			&i.Description,
			&i.TokenHash,
			&i.TokenPrefix,
			&i.ExpiresAt,
			&i.Revoked,
			&i.RevokedAt,
			&i.RevokedReason,
			&i.RevokedBy,
			&i.CreatedBy,
			&i.Scopes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastUsedAt,
			&i.LastUsedIp,
			&i.ApplicationName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeAPIToken = `-- name: RevokeAPIToken :one
UPDATE core_api_tokens
SET 
  revoked = true,
  revoked_at = NOW(),
  revoked_reason = $2,
  revoked_by = $3
WHERE id = $1
RETURNING id, client_application_id, name, description, token_hash, token_prefix, expires_at, revoked, revoked_at, revoked_reason, revoked_by, created_by, scopes, created_at, updated_at, last_used_at, last_used_ip
`

type RevokeAPITokenParams struct {
	ID            uuid.UUID   `json:"id"`
	RevokedReason pgtype.Text `json:"revoked_reason"`
	RevokedBy     pgtype.Text `json:"revoked_by"`
}

func (q *Queries) RevokeAPIToken(ctx context.Context, arg RevokeAPITokenParams) (CoreApiToken, error) {
	row := q.db.QueryRow(ctx, revokeAPIToken, arg.ID, arg.RevokedReason, arg.RevokedBy)
	var i CoreApiToken
	err := row.Scan(
		&i.ID,
		&i.ClientApplicationID,
		&i.Name,
		&i.Description,
		&i.TokenHash,
		&i.TokenPrefix,
		&i.ExpiresAt,
		&i.Revoked,
		&i.RevokedAt,
		&i.RevokedReason,
		&i.RevokedBy,
		&i.CreatedBy,
		&i.Scopes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsedAt,
		&i.LastUsedIp,
	)
	return i, err
}

const updateAPIToken = `-- name: UpdateAPIToken :one
UPDATE core_api_tokens
SET 
  name = $2,
  description = $3,
  expires_at = $4,
  scopes = $5
WHERE id = $1
RETURNING id, client_application_id, name, description, token_hash, token_prefix, expires_at, revoked, revoked_at, revoked_reason, revoked_by, created_by, scopes, created_at, updated_at, last_used_at, last_used_ip
`

type UpdateAPITokenParams struct {
	ID          uuid.UUID   `json:"id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	ExpiresAt   time.Time   `json:"expires_at"`
	Scopes      []string    `json:"scopes"`
}

func (q *Queries) UpdateAPIToken(ctx context.Context, arg UpdateAPITokenParams) (CoreApiToken, error) {
	row := q.db.QueryRow(ctx, updateAPIToken,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.ExpiresAt,
		arg.Scopes,
	)
	var i CoreApiToken
	err := row.Scan(
		&i.ID,
		&i.ClientApplicationID,
		&i.Name,
		&i.Description,
		&i.TokenHash,
		&i.TokenPrefix,
		&i.ExpiresAt,
		&i.Revoked,
		&i.RevokedAt,
		&i.RevokedReason,
		&i.RevokedBy,
		&i.CreatedBy,
		&i.Scopes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsedAt,
		&i.LastUsedIp,
	)
	return i, err
}

const updateAPITokenLastUsed = `-- name: UpdateAPITokenLastUsed :exec
UPDATE core_api_tokens
SET 
  last_used_at = NOW(),
  last_used_ip = $2::varchar
WHERE id = $1
`

type UpdateAPITokenLastUsedParams struct {
	ID        uuid.UUID   `json:"id"`
	IpAddress pgtype.Text `json:"ip_address"`
}

func (q *Queries) UpdateAPITokenLastUsed(ctx context.Context, arg UpdateAPITokenLastUsedParams) error {
	_, err := q.db.Exec(ctx, updateAPITokenLastUsed, arg.ID, arg.IpAddress)
	return err
}
