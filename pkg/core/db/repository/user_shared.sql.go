// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user_shared.sql

package repository

import (
	"context"
	"time"

	subentity "ctoup.com/coreapp/pkg/shared/repository/subentity"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addRoleToUserTenantMembership = `-- name: AddRoleToUserTenantMembership :one
UPDATE core_user_tenant_memberships
SET roles = array_append(roles, $1::TEXT), updated_at = NOW()
WHERE user_id = $2 
  AND tenant_id = $3 
  AND NOT ($1::TEXT = ANY(roles))
RETURNING id, user_id, tenant_id, status, invited_by, invited_at, joined_at, created_at, updated_at, roles
`

type AddRoleToUserTenantMembershipParams struct {
	Role     string `json:"role"`
	UserID   string `json:"user_id"`
	TenantID string `json:"tenant_id"`
}

func (q *Queries) AddRoleToUserTenantMembership(ctx context.Context, arg AddRoleToUserTenantMembershipParams) (CoreUserTenantMembership, error) {
	row := q.db.QueryRow(ctx, addRoleToUserTenantMembership, arg.Role, arg.UserID, arg.TenantID)
	var i CoreUserTenantMembership
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TenantID,
		&i.Status,
		&i.InvitedBy,
		&i.InvitedAt,
		&i.JoinedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Roles,
	)
	return i, err
}

const addSharedUserToTenant = `-- name: AddSharedUserToTenant :one
INSERT INTO core_user_tenant_memberships (
    user_id,
    tenant_id,
    roles,
    status,
    invited_by,
    invited_at,
    joined_at
) VALUES (
    $1,
    $2,
    $3::TEXT[],
    $4,
    $5,
    $6,
    NOW()
)
ON CONFLICT (user_id, tenant_id) 
DO UPDATE SET
    status = EXCLUDED.status,
    roles = EXCLUDED.roles,
    invited_by = COALESCE(core_user_tenant_memberships.invited_by, EXCLUDED.invited_by),
    invited_at = COALESCE(core_user_tenant_memberships.invited_at, EXCLUDED.invited_at),
    joined_at = NOW(),
    updated_at = NOW()
RETURNING id, user_id, tenant_id, status, invited_by, invited_at, joined_at, created_at, updated_at, roles
`

type AddSharedUserToTenantParams struct {
	UserID      string             `json:"user_id"`
	TenantID    string             `json:"tenant_id"`
	TenantRoles []string           `json:"tenant_roles"`
	Status      string             `json:"status"`
	InvitedBy   pgtype.Text        `json:"invited_by"`
	InvitedAt   pgtype.Timestamptz `json:"invited_at"`
}

// Add an existing user to a tenant (insert or reactivate if soft-deleted)
func (q *Queries) AddSharedUserToTenant(ctx context.Context, arg AddSharedUserToTenantParams) (CoreUserTenantMembership, error) {
	row := q.db.QueryRow(ctx, addSharedUserToTenant,
		arg.UserID,
		arg.TenantID,
		arg.TenantRoles,
		arg.Status,
		arg.InvitedBy,
		arg.InvitedAt,
	)
	var i CoreUserTenantMembership
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TenantID,
		&i.Status,
		&i.InvitedBy,
		&i.InvitedAt,
		&i.JoinedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Roles,
	)
	return i, err
}

const checkUserHasTenantRole = `-- name: CheckUserHasTenantRole :one
SELECT EXISTS(
    SELECT 1 FROM core_user_tenant_memberships
    WHERE user_id = $1 
      AND tenant_id = $2 
      AND status = 'active' 
      AND $3::TEXT = ANY(roles)
) as has_role
`

type CheckUserHasTenantRoleParams struct {
	UserID   string `json:"user_id"`
	TenantID string `json:"tenant_id"`
	Role     string `json:"role"`
}

func (q *Queries) CheckUserHasTenantRole(ctx context.Context, arg CheckUserHasTenantRoleParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkUserHasTenantRole, arg.UserID, arg.TenantID, arg.Role)
	var has_role bool
	err := row.Scan(&has_role)
	return has_role, err
}

const checkUserTenantAccess = `-- name: CheckUserTenantAccess :one
SELECT EXISTS(
    SELECT 1 FROM core_user_tenant_memberships
    WHERE user_id = $1 AND tenant_id = $2 AND status = 'active'
) as has_access
`

type CheckUserTenantAccessParams struct {
	UserID   string `json:"user_id"`
	TenantID string `json:"tenant_id"`
}

func (q *Queries) CheckUserTenantAccess(ctx context.Context, arg CheckUserTenantAccessParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkUserTenantAccess, arg.UserID, arg.TenantID)
	var has_access bool
	err := row.Scan(&has_access)
	return has_access, err
}

const countUserTenants = `-- name: CountUserTenants :one
SELECT COUNT(DISTINCT tenant_id)::int
FROM core_user_tenant_memberships
WHERE user_id = $1 AND status = 'active'
`

// Count how many tenants a user belongs to
func (q *Queries) CountUserTenants(ctx context.Context, userID string) (int32, error) {
	row := q.db.QueryRow(ctx, countUserTenants, userID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const createSharedUser = `-- name: CreateSharedUser :one
INSERT INTO core_users (
  "id", "email", "profile", roles
) VALUES (
  $1, $3::text, $2, $4::VARCHAR[]
)
RETURNING id, profile, email, created_at, tenant_id, roles
`

type CreateSharedUserParams struct {
	ID      string                `json:"id"`
	Profile subentity.UserProfile `json:"profile"`
	Email   string                `json:"email"`
	Roles   []string              `json:"roles"`
}

// USED
func (q *Queries) CreateSharedUser(ctx context.Context, arg CreateSharedUserParams) (CoreUser, error) {
	row := q.db.QueryRow(ctx, createSharedUser,
		arg.ID,
		arg.Profile,
		arg.Email,
		arg.Roles,
	)
	var i CoreUser
	err := row.Scan(
		&i.ID,
		&i.Profile,
		&i.Email,
		&i.CreatedAt,
		&i.TenantID,
		&i.Roles,
	)
	return i, err
}

const createSharedUserWithTenant = `-- name: CreateSharedUserWithTenant :one
WITH new_user AS (
    INSERT INTO core_users (
        "id", "email", "profile"
    ) VALUES (
        $1, $3::text, $2
    )
    RETURNING id, profile, email, created_at, tenant_id, roles
),
new_membership AS (
    INSERT INTO core_user_tenant_memberships (
        user_id, 
        tenant_id, 
        roles,
        status,
        invited_by,
        invited_at,
        joined_at
    ) VALUES (
        $1,
        $4,
        $5::TEXT[],
        'active',
        $6,
        $7,
        NOW()
    )
    ON CONFLICT (user_id, tenant_id) 
    DO UPDATE SET
        status = 'active',
        roles = EXCLUDED.roles,
        invited_by = COALESCE(core_user_tenant_memberships.invited_by, EXCLUDED.invited_by),
        invited_at = COALESCE(core_user_tenant_memberships.invited_at, EXCLUDED.invited_at),
        joined_at = NOW(),
        updated_at = NOW()
    RETURNING roles as tenant_roles, status as membership_status, joined_at, tenant_id
)
SELECT 
    new_user.id, new_user.profile, new_user.email, new_user.created_at, new_user.tenant_id, new_user.roles,
    new_membership.tenant_roles,
    new_membership.membership_status,
    new_membership.joined_at,
    new_membership.tenant_id
FROM new_user
CROSS JOIN new_membership
`

type CreateSharedUserWithTenantParams struct {
	ID          string                `json:"id"`
	Profile     subentity.UserProfile `json:"profile"`
	Email       string                `json:"email"`
	TenantID    string                `json:"tenant_id"`
	TenantRoles []string              `json:"tenant_roles"`
	InvitedBy   pgtype.Text           `json:"invited_by"`
	InvitedAt   pgtype.Timestamptz    `json:"invited_at"`
}

type CreateSharedUserWithTenantRow struct {
	ID               string             `json:"id"`
	Profile          []byte             `json:"profile"`
	Email            pgtype.Text        `json:"email"`
	CreatedAt        time.Time          `json:"created_at"`
	TenantID         pgtype.Text        `json:"tenant_id"`
	Roles            []string           `json:"roles"`
	TenantRoles      []string           `json:"tenant_roles"`
	MembershipStatus string             `json:"membership_status"`
	JoinedAt         pgtype.Timestamptz `json:"joined_at"`
	TenantID_2       string             `json:"tenant_id_2"`
}

// USED
func (q *Queries) CreateSharedUserWithTenant(ctx context.Context, arg CreateSharedUserWithTenantParams) (CreateSharedUserWithTenantRow, error) {
	row := q.db.QueryRow(ctx, createSharedUserWithTenant,
		arg.ID,
		arg.Profile,
		arg.Email,
		arg.TenantID,
		arg.TenantRoles,
		arg.InvitedBy,
		arg.InvitedAt,
	)
	var i CreateSharedUserWithTenantRow
	err := row.Scan(
		&i.ID,
		&i.Profile,
		&i.Email,
		&i.CreatedAt,
		&i.TenantID,
		&i.Roles,
		&i.TenantRoles,
		&i.MembershipStatus,
		&i.JoinedAt,
		&i.TenantID_2,
	)
	return i, err
}

const deleteSharedUser = `-- name: DeleteSharedUser :one
DELETE FROM core_users
WHERE id = $1
RETURNING id
`

// This removes the user globally
// The user record itself is deleted
func (q *Queries) DeleteSharedUser(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRow(ctx, deleteSharedUser, id)
	err := row.Scan(&id)
	return id, err
}

const deleteSharedUserByTenant = `-- name: DeleteSharedUserByTenant :one
UPDATE core_user_tenant_memberships
SET status = 'inactive',
    updated_at = NOW(),
    left_at = NOW()
WHERE user_id = $1 
    AND tenant_id = $2
RETURNING user_id as id
`

type DeleteSharedUserByTenantParams struct {
	UserID   string `json:"user_id"`
	TenantID string `json:"tenant_id"`
}

// This removes the user's membership from the tenant
// The user record itself remains (they may belong to other tenants)
func (q *Queries) DeleteSharedUserByTenant(ctx context.Context, arg DeleteSharedUserByTenantParams) (string, error) {
	row := q.db.QueryRow(ctx, deleteSharedUserByTenant, arg.UserID, arg.TenantID)
	var id string
	err := row.Scan(&id)
	return id, err
}

const getSharedUserByID = `-- name: GetSharedUserByID :one
SELECT id, profile, email, created_at, tenant_id, roles FROM core_users
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetSharedUserByID(ctx context.Context, id string) (CoreUser, error) {
	row := q.db.QueryRow(ctx, getSharedUserByID, id)
	var i CoreUser
	err := row.Scan(
		&i.ID,
		&i.Profile,
		&i.Email,
		&i.CreatedAt,
		&i.TenantID,
		&i.Roles,
	)
	return i, err
}

const getSharedUserByTenantByEmail = `-- name: GetSharedUserByTenantByEmail :one
SELECT 
    u.id, u.profile, u.email, u.created_at, u.tenant_id, u.roles,
    utm.roles as tenant_roles,
    utm.status as membership_status,
    utm.joined_at,
    utm.tenant_id
FROM core_users u
INNER JOIN core_user_tenant_memberships utm ON u.id = utm.user_id
WHERE u.email = $1::text
    AND utm.tenant_id = $2
    AND utm.status = 'active'
LIMIT 1
`

type GetSharedUserByTenantByEmailParams struct {
	Email    string `json:"email"`
	TenantID string `json:"tenant_id"`
}

type GetSharedUserByTenantByEmailRow struct {
	ID               string                `json:"id"`
	Profile          subentity.UserProfile `json:"profile"`
	Email            pgtype.Text           `json:"email"`
	CreatedAt        time.Time             `json:"created_at"`
	TenantID         pgtype.Text           `json:"tenant_id"`
	Roles            []string              `json:"roles"`
	TenantRoles      []string              `json:"tenant_roles"`
	MembershipStatus string                `json:"membership_status"`
	JoinedAt         pgtype.Timestamptz    `json:"joined_at"`
	TenantID_2       string                `json:"tenant_id_2"`
}

func (q *Queries) GetSharedUserByTenantByEmail(ctx context.Context, arg GetSharedUserByTenantByEmailParams) (GetSharedUserByTenantByEmailRow, error) {
	row := q.db.QueryRow(ctx, getSharedUserByTenantByEmail, arg.Email, arg.TenantID)
	var i GetSharedUserByTenantByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Profile,
		&i.Email,
		&i.CreatedAt,
		&i.TenantID,
		&i.Roles,
		&i.TenantRoles,
		&i.MembershipStatus,
		&i.JoinedAt,
		&i.TenantID_2,
	)
	return i, err
}

const getSharedUserByTenantByID = `-- name: GetSharedUserByTenantByID :one
SELECT 
    u.id, u.profile, u.email, u.created_at, u.tenant_id, u.roles,
    utm.roles as tenant_roles,
    utm.status as membership_status,
    utm.joined_at,
    utm.tenant_id
FROM core_users u
INNER JOIN core_user_tenant_memberships utm ON u.id = utm.user_id
WHERE u.id = $1 
    AND utm.tenant_id = $2
    AND utm.status = 'active'
LIMIT 1
`

type GetSharedUserByTenantByIDParams struct {
	ID       string `json:"id"`
	TenantID string `json:"tenant_id"`
}

type GetSharedUserByTenantByIDRow struct {
	ID               string                `json:"id"`
	Profile          subentity.UserProfile `json:"profile"`
	Email            pgtype.Text           `json:"email"`
	CreatedAt        time.Time             `json:"created_at"`
	TenantID         pgtype.Text           `json:"tenant_id"`
	Roles            []string              `json:"roles"`
	TenantRoles      []string              `json:"tenant_roles"`
	MembershipStatus string                `json:"membership_status"`
	JoinedAt         pgtype.Timestamptz    `json:"joined_at"`
	TenantID_2       string                `json:"tenant_id_2"`
}

func (q *Queries) GetSharedUserByTenantByID(ctx context.Context, arg GetSharedUserByTenantByIDParams) (GetSharedUserByTenantByIDRow, error) {
	row := q.db.QueryRow(ctx, getSharedUserByTenantByID, arg.ID, arg.TenantID)
	var i GetSharedUserByTenantByIDRow
	err := row.Scan(
		&i.ID,
		&i.Profile,
		&i.Email,
		&i.CreatedAt,
		&i.TenantID,
		&i.Roles,
		&i.TenantRoles,
		&i.MembershipStatus,
		&i.JoinedAt,
		&i.TenantID_2,
	)
	return i, err
}

const getSharedUserTenantMembership = `-- name: GetSharedUserTenantMembership :one
SELECT id, user_id, tenant_id, status, invited_by, invited_at, joined_at, created_at, updated_at, roles FROM core_user_tenant_memberships
WHERE user_id = $1 AND tenant_id = $2
LIMIT 1
`

type GetSharedUserTenantMembershipParams struct {
	UserID   string `json:"user_id"`
	TenantID string `json:"tenant_id"`
}

func (q *Queries) GetSharedUserTenantMembership(ctx context.Context, arg GetSharedUserTenantMembershipParams) (CoreUserTenantMembership, error) {
	row := q.db.QueryRow(ctx, getSharedUserTenantMembership, arg.UserID, arg.TenantID)
	var i CoreUserTenantMembership
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TenantID,
		&i.Status,
		&i.InvitedBy,
		&i.InvitedAt,
		&i.JoinedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Roles,
	)
	return i, err
}

const getSharedUserWithAllTenants = `-- name: GetSharedUserWithAllTenants :one
SELECT 
    u.id,
    u.email,
    u.profile,
    u.roles as global_roles,
    u.created_at,
    COALESCE(
        json_agg(
            json_build_object(
                'tenant_id', utm.tenant_id,
                'roles', utm.roles,
                'status', utm.status,
                'joined_at', utm.joined_at
            )
        ) FILTER (WHERE utm.tenant_id IS NOT NULL),
        '[]'
    ) as tenants
FROM core_users u
LEFT JOIN core_user_tenant_memberships utm 
    ON u.id = utm.user_id 
    AND utm.status = 'active'
LEFT JOIN core_tenants t 
    ON utm.tenant_id = t.tenant_id
WHERE u.id = $1
GROUP BY u.id
`

type GetSharedUserWithAllTenantsRow struct {
	ID          string                `json:"id"`
	Email       pgtype.Text           `json:"email"`
	Profile     subentity.UserProfile `json:"profile"`
	GlobalRoles []string              `json:"global_roles"`
	CreatedAt   time.Time             `json:"created_at"`
	Tenants     interface{}           `json:"tenants"`
}

// Get user with all their tenant memberships
func (q *Queries) GetSharedUserWithAllTenants(ctx context.Context, id string) (GetSharedUserWithAllTenantsRow, error) {
	row := q.db.QueryRow(ctx, getSharedUserWithAllTenants, id)
	var i GetSharedUserWithAllTenantsRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Profile,
		&i.GlobalRoles,
		&i.CreatedAt,
		&i.Tenants,
	)
	return i, err
}

const getUserByEmailGlobal = `-- name: GetUserByEmailGlobal :one
SELECT DISTINCT ON (id) 
    id, 
    email, 
    profile, 
    created_at
FROM core_users
WHERE email = $1::text
LIMIT 1
`

type GetUserByEmailGlobalRow struct {
	ID        string                `json:"id"`
	Email     pgtype.Text           `json:"email"`
	Profile   subentity.UserProfile `json:"profile"`
	CreatedAt time.Time             `json:"created_at"`
}

// Get user by email across all tenants (for checking existence)
// This returns the first user found with this email
func (q *Queries) GetUserByEmailGlobal(ctx context.Context, email string) (GetUserByEmailGlobalRow, error) {
	row := q.db.QueryRow(ctx, getUserByEmailGlobal, email)
	var i GetUserByEmailGlobalRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Profile,
		&i.CreatedAt,
	)
	return i, err
}

const getUserTenantRoles = `-- name: GetUserTenantRoles :one
SELECT roles FROM core_user_tenant_memberships
WHERE user_id = $1 AND tenant_id = $2 AND status = 'active'
LIMIT 1
`

type GetUserTenantRolesParams struct {
	UserID   string `json:"user_id"`
	TenantID string `json:"tenant_id"`
}

func (q *Queries) GetUserTenantRoles(ctx context.Context, arg GetUserTenantRolesParams) ([]string, error) {
	row := q.db.QueryRow(ctx, getUserTenantRoles, arg.UserID, arg.TenantID)
	var roles []string
	err := row.Scan(&roles)
	return roles, err
}

const isUserMemberOfTenant = `-- name: IsUserMemberOfTenant :one
SELECT EXISTS(
    SELECT 1 FROM core_user_tenant_memberships
    WHERE user_id = $1 AND tenant_id = $2 AND status = 'active'
) as is_member
`

type IsUserMemberOfTenantParams struct {
	UserID   string `json:"user_id"`
	TenantID string `json:"tenant_id"`
}

// Check if user is already an active member of a specific tenant
func (q *Queries) IsUserMemberOfTenant(ctx context.Context, arg IsUserMemberOfTenantParams) (bool, error) {
	row := q.db.QueryRow(ctx, isUserMemberOfTenant, arg.UserID, arg.TenantID)
	var is_member bool
	err := row.Scan(&is_member)
	return is_member, err
}

const listPendingInvitations = `-- name: ListPendingInvitations :many
SELECT 
    utm.id, utm.user_id, utm.tenant_id, utm.status, utm.invited_by, utm.invited_at, utm.joined_at, utm.created_at, utm.updated_at, utm.roles,
    t.name as tenant_name,
    t.subdomain
FROM core_user_tenant_memberships utm
JOIN core_tenants t ON utm.tenant_id = t.tenant_id
WHERE utm.user_id = $1 AND utm.status = 'pending'
ORDER BY utm.invited_at DESC
`

type ListPendingInvitationsRow struct {
	ID         uuid.UUID          `json:"id"`
	UserID     string             `json:"user_id"`
	TenantID   string             `json:"tenant_id"`
	Status     string             `json:"status"`
	InvitedBy  pgtype.Text        `json:"invited_by"`
	InvitedAt  pgtype.Timestamptz `json:"invited_at"`
	JoinedAt   pgtype.Timestamptz `json:"joined_at"`
	CreatedAt  time.Time          `json:"created_at"`
	UpdatedAt  time.Time          `json:"updated_at"`
	Roles      []string           `json:"roles"`
	TenantName string             `json:"tenant_name"`
	Subdomain  string             `json:"subdomain"`
}

func (q *Queries) ListPendingInvitations(ctx context.Context, userID string) ([]ListPendingInvitationsRow, error) {
	rows, err := q.db.Query(ctx, listPendingInvitations, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPendingInvitationsRow{}
	for rows.Next() {
		var i ListPendingInvitationsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TenantID,
			&i.Status,
			&i.InvitedBy,
			&i.InvitedAt,
			&i.JoinedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Roles,
			&i.TenantName,
			&i.Subdomain,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSharedUsersByRoles = `-- name: ListSharedUsersByRoles :many
SELECT 
    id, 
    email, 
    profile, 
    roles, 
    created_at
FROM core_users
WHERE 
    -- Use GIN index for array overlap
    roles && $3::VARCHAR[]
    -- Optimize email search
    AND (
        email ILIKE $4::text || '%'
        OR $4 IS NULL
    )
ORDER BY email ASC
LIMIT $1
OFFSET $2
`

type ListSharedUsersByRolesParams struct {
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
	RequestedRoles []string    `json:"requested_roles"`
	SearchPrefix   pgtype.Text `json:"search_prefix"`
}

type ListSharedUsersByRolesRow struct {
	ID        string                `json:"id"`
	Email     pgtype.Text           `json:"email"`
	Profile   subentity.UserProfile `json:"profile"`
	Roles     []string              `json:"roles"`
	CreatedAt time.Time             `json:"created_at"`
}

func (q *Queries) ListSharedUsersByRoles(ctx context.Context, arg ListSharedUsersByRolesParams) ([]ListSharedUsersByRolesRow, error) {
	rows, err := q.db.Query(ctx, listSharedUsersByRoles,
		arg.Limit,
		arg.Offset,
		arg.RequestedRoles,
		arg.SearchPrefix,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSharedUsersByRolesRow{}
	for rows.Next() {
		var i ListSharedUsersByRolesRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Profile,
			&i.Roles,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSharedUsersByTenant = `-- name: ListSharedUsersByTenant :many
SELECT 
    u.id, u.profile, u.email, u.created_at, u.tenant_id, u.roles,
    utm.roles as tenant_roles,
    utm.status as membership_status,
    utm.joined_at
FROM core_users u
INNER JOIN core_user_tenant_memberships utm ON u.id = utm.user_id
WHERE utm.tenant_id = $3
    AND utm.status = 'active'
    AND (
        email ILIKE $4::text || '%'
        OR $4 IS NULL
    )
ORDER BY u.created_at
LIMIT $1
OFFSET $2
`

type ListSharedUsersByTenantParams struct {
	Limit        int32       `json:"limit"`
	Offset       int32       `json:"offset"`
	TenantID     string      `json:"tenant_id"`
	SearchPrefix pgtype.Text `json:"search_prefix"`
}

type ListSharedUsersByTenantRow struct {
	ID               string                `json:"id"`
	Profile          subentity.UserProfile `json:"profile"`
	Email            pgtype.Text           `json:"email"`
	CreatedAt        time.Time             `json:"created_at"`
	TenantID         pgtype.Text           `json:"tenant_id"`
	Roles            []string              `json:"roles"`
	TenantRoles      []string              `json:"tenant_roles"`
	MembershipStatus string                `json:"membership_status"`
	JoinedAt         pgtype.Timestamptz    `json:"joined_at"`
}

func (q *Queries) ListSharedUsersByTenant(ctx context.Context, arg ListSharedUsersByTenantParams) ([]ListSharedUsersByTenantRow, error) {
	rows, err := q.db.Query(ctx, listSharedUsersByTenant,
		arg.Limit,
		arg.Offset,
		arg.TenantID,
		arg.SearchPrefix,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSharedUsersByTenantRow{}
	for rows.Next() {
		var i ListSharedUsersByTenantRow
		if err := rows.Scan(
			&i.ID,
			&i.Profile,
			&i.Email,
			&i.CreatedAt,
			&i.TenantID,
			&i.Roles,
			&i.TenantRoles,
			&i.MembershipStatus,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTenantMembers = `-- name: ListTenantMembers :many
SELECT utm.id, utm.user_id, utm.tenant_id, utm.status, utm.invited_by, utm.invited_at, utm.joined_at, utm.created_at, utm.updated_at, utm.roles
FROM core_user_tenant_memberships utm
WHERE utm.tenant_id = $1 AND utm.status = $2
ORDER BY utm.created_at DESC
`

type ListTenantMembersParams struct {
	TenantID string `json:"tenant_id"`
	Status   string `json:"status"`
}

func (q *Queries) ListTenantMembers(ctx context.Context, arg ListTenantMembersParams) ([]CoreUserTenantMembership, error) {
	rows, err := q.db.Query(ctx, listTenantMembers, arg.TenantID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CoreUserTenantMembership{}
	for rows.Next() {
		var i CoreUserTenantMembership
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TenantID,
			&i.Status,
			&i.InvitedBy,
			&i.InvitedAt,
			&i.JoinedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Roles,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserTenantMemberships = `-- name: ListUserTenantMemberships :many
SELECT 
    utm.id, utm.user_id, utm.tenant_id, utm.status, utm.invited_by, utm.invited_at, utm.joined_at, utm.created_at, utm.updated_at, utm.roles,
    t.name as tenant_name,
    t.subdomain
FROM core_user_tenant_memberships utm
JOIN core_tenants t ON utm.tenant_id = t.tenant_id
WHERE utm.user_id = $1 AND utm.status = $2
ORDER BY utm.created_at DESC
`

type ListUserTenantMembershipsParams struct {
	UserID string `json:"user_id"`
	Status string `json:"status"`
}

type ListUserTenantMembershipsRow struct {
	ID         uuid.UUID          `json:"id"`
	UserID     string             `json:"user_id"`
	TenantID   string             `json:"tenant_id"`
	Status     string             `json:"status"`
	InvitedBy  pgtype.Text        `json:"invited_by"`
	InvitedAt  pgtype.Timestamptz `json:"invited_at"`
	JoinedAt   pgtype.Timestamptz `json:"joined_at"`
	CreatedAt  time.Time          `json:"created_at"`
	UpdatedAt  time.Time          `json:"updated_at"`
	Roles      []string           `json:"roles"`
	TenantName string             `json:"tenant_name"`
	Subdomain  string             `json:"subdomain"`
}

func (q *Queries) ListUserTenantMemberships(ctx context.Context, arg ListUserTenantMembershipsParams) ([]ListUserTenantMembershipsRow, error) {
	rows, err := q.db.Query(ctx, listUserTenantMemberships, arg.UserID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserTenantMembershipsRow{}
	for rows.Next() {
		var i ListUserTenantMembershipsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TenantID,
			&i.Status,
			&i.InvitedBy,
			&i.InvitedAt,
			&i.JoinedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Roles,
			&i.TenantName,
			&i.Subdomain,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeRoleFromUserTenantMembership = `-- name: RemoveRoleFromUserTenantMembership :one
UPDATE core_user_tenant_memberships
SET roles = array_remove(roles, $1::TEXT), updated_at = NOW()
WHERE user_id = $2 
  AND tenant_id = $3 
  AND $1::TEXT = ANY(roles)
RETURNING id, user_id, tenant_id, status, invited_by, invited_at, joined_at, created_at, updated_at, roles
`

type RemoveRoleFromUserTenantMembershipParams struct {
	Role     string `json:"role"`
	UserID   string `json:"user_id"`
	TenantID string `json:"tenant_id"`
}

func (q *Queries) RemoveRoleFromUserTenantMembership(ctx context.Context, arg RemoveRoleFromUserTenantMembershipParams) (CoreUserTenantMembership, error) {
	row := q.db.QueryRow(ctx, removeRoleFromUserTenantMembership, arg.Role, arg.UserID, arg.TenantID)
	var i CoreUserTenantMembership
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TenantID,
		&i.Status,
		&i.InvitedBy,
		&i.InvitedAt,
		&i.JoinedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Roles,
	)
	return i, err
}

const removeSharedUserFromTenant = `-- name: RemoveSharedUserFromTenant :exec
DELETE FROM core_user_tenant_memberships
WHERE user_id = $1 
    AND tenant_id = $2
`

type RemoveSharedUserFromTenantParams struct {
	UserID   string `json:"user_id"`
	TenantID string `json:"tenant_id"`
}

// Hard delete: completely remove user from tenant
func (q *Queries) RemoveSharedUserFromTenant(ctx context.Context, arg RemoveSharedUserFromTenantParams) error {
	_, err := q.db.Exec(ctx, removeSharedUserFromTenant, arg.UserID, arg.TenantID)
	return err
}

const updateSharedProfile = `-- name: UpdateSharedProfile :one
UPDATE core_users 
SET profile = $1
WHERE core_users.id = $2
RETURNING id
`

type UpdateSharedProfileParams struct {
	Profile subentity.UserProfile `json:"profile"`
	ID      string                `json:"id"`
}

func (q *Queries) UpdateSharedProfile(ctx context.Context, arg UpdateSharedProfileParams) (string, error) {
	row := q.db.QueryRow(ctx, updateSharedProfile, arg.Profile, arg.ID)
	var id string
	err := row.Scan(&id)
	return id, err
}

const updateSharedUser = `-- name: UpdateSharedUser :one
UPDATE core_users 
SET 
    roles = $2::VARCHAR[],
    profile = jsonb_set(
        profile, 
        '{name}', 
        to_jsonb($3::text), 
        true
    )
WHERE id = $1
RETURNING id
`

type UpdateSharedUserParams struct {
	ID    string   `json:"id"`
	Roles []string `json:"roles"`
	Name  string   `json:"name"`
}

func (q *Queries) UpdateSharedUser(ctx context.Context, arg UpdateSharedUserParams) (string, error) {
	row := q.db.QueryRow(ctx, updateSharedUser, arg.ID, arg.Roles, arg.Name)
	var id string
	err := row.Scan(&id)
	return id, err
}

const updateSharedUserByTenant = `-- name: UpdateSharedUserByTenant :one
WITH updated_user AS (
    UPDATE core_users 
    SET 
        roles = $2::VARCHAR[],
        profile = jsonb_set(
            profile, 
            '{name}', 
            to_jsonb($3::text), 
            true
        )
    WHERE core_users.id = $1
        AND EXISTS (
            SELECT 1 FROM core_user_tenant_memberships
            WHERE user_id = $1 
                AND core_user_tenant_memberships.tenant_id = $4
                AND status = 'active'
        )
    RETURNING id
),
updated_membership AS (
    UPDATE core_user_tenant_memberships
    SET roles = $5::TEXT[],
        updated_at = NOW()
    WHERE user_id = $1 
        AND tenant_id = $4
    RETURNING user_id
)
SELECT COALESCE(updated_user.id, updated_membership.user_id) as id
FROM updated_user
FULL OUTER JOIN updated_membership ON updated_user.id = updated_membership.user_id
`

type UpdateSharedUserByTenantParams struct {
	ID          string   `json:"id"`
	Roles       []string `json:"roles"`
	Name        string   `json:"name"`
	TenantID    string   `json:"tenant_id"`
	TenantRoles []string `json:"tenant_roles"`
}

func (q *Queries) UpdateSharedUserByTenant(ctx context.Context, arg UpdateSharedUserByTenantParams) (string, error) {
	row := q.db.QueryRow(ctx, updateSharedUserByTenant,
		arg.ID,
		arg.Roles,
		arg.Name,
		arg.TenantID,
		arg.TenantRoles,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const updateSharedUserGlobalRoles = `-- name: UpdateSharedUserGlobalRoles :one
UPDATE core_users
SET roles = $2::VARCHAR[]
WHERE id = $1
RETURNING id
`

type UpdateSharedUserGlobalRolesParams struct {
	ID    string   `json:"id"`
	Roles []string `json:"roles"`
}

// Update a user's global roles only
func (q *Queries) UpdateSharedUserGlobalRoles(ctx context.Context, arg UpdateSharedUserGlobalRolesParams) (string, error) {
	row := q.db.QueryRow(ctx, updateSharedUserGlobalRoles, arg.ID, arg.Roles)
	var id string
	err := row.Scan(&id)
	return id, err
}

const updateSharedUserRolesInTenant = `-- name: UpdateSharedUserRolesInTenant :one
UPDATE core_user_tenant_memberships
SET roles = $2::TEXT[],
    updated_at = NOW()
WHERE user_id = $1 
    AND tenant_id = $3
RETURNING id, user_id, tenant_id, status, invited_by, invited_at, joined_at, created_at, updated_at, roles
`

type UpdateSharedUserRolesInTenantParams struct {
	UserID      string   `json:"user_id"`
	TenantRoles []string `json:"tenant_roles"`
	TenantID    string   `json:"tenant_id"`
}

// Update a user's tenant-specific roles only
func (q *Queries) UpdateSharedUserRolesInTenant(ctx context.Context, arg UpdateSharedUserRolesInTenantParams) (CoreUserTenantMembership, error) {
	row := q.db.QueryRow(ctx, updateSharedUserRolesInTenant, arg.UserID, arg.TenantRoles, arg.TenantID)
	var i CoreUserTenantMembership
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TenantID,
		&i.Status,
		&i.InvitedBy,
		&i.InvitedAt,
		&i.JoinedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Roles,
	)
	return i, err
}

const updateUserTenantMembershipJoinedAt = `-- name: UpdateUserTenantMembershipJoinedAt :one
UPDATE core_user_tenant_memberships
SET joined_at = $3, status = 'active', updated_at = NOW()
WHERE user_id = $1 AND tenant_id = $2
RETURNING id, user_id, tenant_id, status, invited_by, invited_at, joined_at, created_at, updated_at, roles
`

type UpdateUserTenantMembershipJoinedAtParams struct {
	UserID   string             `json:"user_id"`
	TenantID string             `json:"tenant_id"`
	JoinedAt pgtype.Timestamptz `json:"joined_at"`
}

func (q *Queries) UpdateUserTenantMembershipJoinedAt(ctx context.Context, arg UpdateUserTenantMembershipJoinedAtParams) (CoreUserTenantMembership, error) {
	row := q.db.QueryRow(ctx, updateUserTenantMembershipJoinedAt, arg.UserID, arg.TenantID, arg.JoinedAt)
	var i CoreUserTenantMembership
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TenantID,
		&i.Status,
		&i.InvitedBy,
		&i.InvitedAt,
		&i.JoinedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Roles,
	)
	return i, err
}

const updateUserTenantMembershipRoles = `-- name: UpdateUserTenantMembershipRoles :one
UPDATE core_user_tenant_memberships
SET roles = $3, updated_at = NOW()
WHERE user_id = $1 AND tenant_id = $2
RETURNING id, user_id, tenant_id, status, invited_by, invited_at, joined_at, created_at, updated_at, roles
`

type UpdateUserTenantMembershipRolesParams struct {
	UserID   string   `json:"user_id"`
	TenantID string   `json:"tenant_id"`
	Roles    []string `json:"roles"`
}

func (q *Queries) UpdateUserTenantMembershipRoles(ctx context.Context, arg UpdateUserTenantMembershipRolesParams) (CoreUserTenantMembership, error) {
	row := q.db.QueryRow(ctx, updateUserTenantMembershipRoles, arg.UserID, arg.TenantID, arg.Roles)
	var i CoreUserTenantMembership
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TenantID,
		&i.Status,
		&i.InvitedBy,
		&i.InvitedAt,
		&i.JoinedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Roles,
	)
	return i, err
}

const updateUserTenantMembershipStatus = `-- name: UpdateUserTenantMembershipStatus :one
UPDATE core_user_tenant_memberships
SET status = $3, updated_at = NOW()
WHERE user_id = $1 AND tenant_id = $2
RETURNING id, user_id, tenant_id, status, invited_by, invited_at, joined_at, created_at, updated_at, roles
`

type UpdateUserTenantMembershipStatusParams struct {
	UserID   string `json:"user_id"`
	TenantID string `json:"tenant_id"`
	Status   string `json:"status"`
}

func (q *Queries) UpdateUserTenantMembershipStatus(ctx context.Context, arg UpdateUserTenantMembershipStatusParams) (CoreUserTenantMembership, error) {
	row := q.db.QueryRow(ctx, updateUserTenantMembershipStatus, arg.UserID, arg.TenantID, arg.Status)
	var i CoreUserTenantMembership
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TenantID,
		&i.Status,
		&i.InvitedBy,
		&i.InvitedAt,
		&i.JoinedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Roles,
	)
	return i, err
}
