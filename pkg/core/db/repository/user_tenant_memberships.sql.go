// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user_tenant_memberships.sql

package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const checkUserTenantAccess = `-- name: CheckUserTenantAccess :one
SELECT EXISTS(
    SELECT 1 FROM core_user_tenant_memberships
    WHERE user_id = $1 AND tenant_id = $2 AND status = 'active'
) as has_access
`

type CheckUserTenantAccessParams struct {
	UserID   string `json:"user_id"`
	TenantID string `json:"tenant_id"`
}

func (q *Queries) CheckUserTenantAccess(ctx context.Context, arg CheckUserTenantAccessParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkUserTenantAccess, arg.UserID, arg.TenantID)
	var has_access bool
	err := row.Scan(&has_access)
	return has_access, err
}

const createUserTenantMembership = `-- name: CreateUserTenantMembership :one
INSERT INTO core_user_tenant_memberships (
    user_id,
    tenant_id,
    role,
    status,
    invited_by,
    invited_at,
    joined_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, user_id, tenant_id, role, status, invited_by, invited_at, joined_at, created_at, updated_at
`

type CreateUserTenantMembershipParams struct {
	UserID    string             `json:"user_id"`
	TenantID  string             `json:"tenant_id"`
	Role      string             `json:"role"`
	Status    string             `json:"status"`
	InvitedBy pgtype.Text        `json:"invited_by"`
	InvitedAt pgtype.Timestamptz `json:"invited_at"`
	JoinedAt  pgtype.Timestamptz `json:"joined_at"`
}

func (q *Queries) CreateUserTenantMembership(ctx context.Context, arg CreateUserTenantMembershipParams) (CoreUserTenantMembership, error) {
	row := q.db.QueryRow(ctx, createUserTenantMembership,
		arg.UserID,
		arg.TenantID,
		arg.Role,
		arg.Status,
		arg.InvitedBy,
		arg.InvitedAt,
		arg.JoinedAt,
	)
	var i CoreUserTenantMembership
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TenantID,
		&i.Role,
		&i.Status,
		&i.InvitedBy,
		&i.InvitedAt,
		&i.JoinedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUserTenantMembership = `-- name: DeleteUserTenantMembership :exec
DELETE FROM core_user_tenant_memberships
WHERE user_id = $1 AND tenant_id = $2
`

type DeleteUserTenantMembershipParams struct {
	UserID   string `json:"user_id"`
	TenantID string `json:"tenant_id"`
}

func (q *Queries) DeleteUserTenantMembership(ctx context.Context, arg DeleteUserTenantMembershipParams) error {
	_, err := q.db.Exec(ctx, deleteUserTenantMembership, arg.UserID, arg.TenantID)
	return err
}

const getUserTenantMembership = `-- name: GetUserTenantMembership :one
SELECT id, user_id, tenant_id, role, status, invited_by, invited_at, joined_at, created_at, updated_at FROM core_user_tenant_memberships
WHERE user_id = $1 AND tenant_id = $2
LIMIT 1
`

type GetUserTenantMembershipParams struct {
	UserID   string `json:"user_id"`
	TenantID string `json:"tenant_id"`
}

func (q *Queries) GetUserTenantMembership(ctx context.Context, arg GetUserTenantMembershipParams) (CoreUserTenantMembership, error) {
	row := q.db.QueryRow(ctx, getUserTenantMembership, arg.UserID, arg.TenantID)
	var i CoreUserTenantMembership
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TenantID,
		&i.Role,
		&i.Status,
		&i.InvitedBy,
		&i.InvitedAt,
		&i.JoinedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listPendingInvitations = `-- name: ListPendingInvitations :many
SELECT 
    utm.id, utm.user_id, utm.tenant_id, utm.role, utm.status, utm.invited_by, utm.invited_at, utm.joined_at, utm.created_at, utm.updated_at,
    t.name as tenant_name,
    t.subdomain
FROM core_user_tenant_memberships utm
JOIN core_tenants t ON utm.tenant_id = t.tenant_id
WHERE utm.user_id = $1 AND utm.status = 'pending'
ORDER BY utm.invited_at DESC
`

type ListPendingInvitationsRow struct {
	ID         uuid.UUID          `json:"id"`
	UserID     string             `json:"user_id"`
	TenantID   string             `json:"tenant_id"`
	Role       string             `json:"role"`
	Status     string             `json:"status"`
	InvitedBy  pgtype.Text        `json:"invited_by"`
	InvitedAt  pgtype.Timestamptz `json:"invited_at"`
	JoinedAt   pgtype.Timestamptz `json:"joined_at"`
	CreatedAt  time.Time          `json:"created_at"`
	UpdatedAt  time.Time          `json:"updated_at"`
	TenantName string             `json:"tenant_name"`
	Subdomain  string             `json:"subdomain"`
}

func (q *Queries) ListPendingInvitations(ctx context.Context, userID string) ([]ListPendingInvitationsRow, error) {
	rows, err := q.db.Query(ctx, listPendingInvitations, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPendingInvitationsRow{}
	for rows.Next() {
		var i ListPendingInvitationsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TenantID,
			&i.Role,
			&i.Status,
			&i.InvitedBy,
			&i.InvitedAt,
			&i.JoinedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TenantName,
			&i.Subdomain,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTenantMembers = `-- name: ListTenantMembers :many
SELECT utm.id, utm.user_id, utm.tenant_id, utm.role, utm.status, utm.invited_by, utm.invited_at, utm.joined_at, utm.created_at, utm.updated_at
FROM core_user_tenant_memberships utm
WHERE utm.tenant_id = $1 AND utm.status = $2
ORDER BY utm.created_at DESC
`

type ListTenantMembersParams struct {
	TenantID string `json:"tenant_id"`
	Status   string `json:"status"`
}

func (q *Queries) ListTenantMembers(ctx context.Context, arg ListTenantMembersParams) ([]CoreUserTenantMembership, error) {
	rows, err := q.db.Query(ctx, listTenantMembers, arg.TenantID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CoreUserTenantMembership{}
	for rows.Next() {
		var i CoreUserTenantMembership
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TenantID,
			&i.Role,
			&i.Status,
			&i.InvitedBy,
			&i.InvitedAt,
			&i.JoinedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserTenantMemberships = `-- name: ListUserTenantMemberships :many
SELECT 
    utm.id, utm.user_id, utm.tenant_id, utm.role, utm.status, utm.invited_by, utm.invited_at, utm.joined_at, utm.created_at, utm.updated_at,
    t.name as tenant_name,
    t.subdomain
FROM core_user_tenant_memberships utm
JOIN core_tenants t ON utm.tenant_id = t.tenant_id
WHERE utm.user_id = $1 AND utm.status = $2
ORDER BY utm.created_at DESC
`

type ListUserTenantMembershipsParams struct {
	UserID string `json:"user_id"`
	Status string `json:"status"`
}

type ListUserTenantMembershipsRow struct {
	ID         uuid.UUID          `json:"id"`
	UserID     string             `json:"user_id"`
	TenantID   string             `json:"tenant_id"`
	Role       string             `json:"role"`
	Status     string             `json:"status"`
	InvitedBy  pgtype.Text        `json:"invited_by"`
	InvitedAt  pgtype.Timestamptz `json:"invited_at"`
	JoinedAt   pgtype.Timestamptz `json:"joined_at"`
	CreatedAt  time.Time          `json:"created_at"`
	UpdatedAt  time.Time          `json:"updated_at"`
	TenantName string             `json:"tenant_name"`
	Subdomain  string             `json:"subdomain"`
}

func (q *Queries) ListUserTenantMemberships(ctx context.Context, arg ListUserTenantMembershipsParams) ([]ListUserTenantMembershipsRow, error) {
	rows, err := q.db.Query(ctx, listUserTenantMemberships, arg.UserID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserTenantMembershipsRow{}
	for rows.Next() {
		var i ListUserTenantMembershipsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TenantID,
			&i.Role,
			&i.Status,
			&i.InvitedBy,
			&i.InvitedAt,
			&i.JoinedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TenantName,
			&i.Subdomain,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserTenantMembershipJoinedAt = `-- name: UpdateUserTenantMembershipJoinedAt :one
UPDATE core_user_tenant_memberships
SET joined_at = $3, status = 'active', updated_at = clock_timestamp()
WHERE user_id = $1 AND tenant_id = $2
RETURNING id, user_id, tenant_id, role, status, invited_by, invited_at, joined_at, created_at, updated_at
`

type UpdateUserTenantMembershipJoinedAtParams struct {
	UserID   string             `json:"user_id"`
	TenantID string             `json:"tenant_id"`
	JoinedAt pgtype.Timestamptz `json:"joined_at"`
}

func (q *Queries) UpdateUserTenantMembershipJoinedAt(ctx context.Context, arg UpdateUserTenantMembershipJoinedAtParams) (CoreUserTenantMembership, error) {
	row := q.db.QueryRow(ctx, updateUserTenantMembershipJoinedAt, arg.UserID, arg.TenantID, arg.JoinedAt)
	var i CoreUserTenantMembership
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TenantID,
		&i.Role,
		&i.Status,
		&i.InvitedBy,
		&i.InvitedAt,
		&i.JoinedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserTenantMembershipRole = `-- name: UpdateUserTenantMembershipRole :one
UPDATE core_user_tenant_memberships
SET role = $3, updated_at = clock_timestamp()
WHERE user_id = $1 AND tenant_id = $2
RETURNING id, user_id, tenant_id, role, status, invited_by, invited_at, joined_at, created_at, updated_at
`

type UpdateUserTenantMembershipRoleParams struct {
	UserID   string `json:"user_id"`
	TenantID string `json:"tenant_id"`
	Role     string `json:"role"`
}

func (q *Queries) UpdateUserTenantMembershipRole(ctx context.Context, arg UpdateUserTenantMembershipRoleParams) (CoreUserTenantMembership, error) {
	row := q.db.QueryRow(ctx, updateUserTenantMembershipRole, arg.UserID, arg.TenantID, arg.Role)
	var i CoreUserTenantMembership
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TenantID,
		&i.Role,
		&i.Status,
		&i.InvitedBy,
		&i.InvitedAt,
		&i.JoinedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserTenantMembershipStatus = `-- name: UpdateUserTenantMembershipStatus :one
UPDATE core_user_tenant_memberships
SET status = $3, updated_at = clock_timestamp()
WHERE user_id = $1 AND tenant_id = $2
RETURNING id, user_id, tenant_id, role, status, invited_by, invited_at, joined_at, created_at, updated_at
`

type UpdateUserTenantMembershipStatusParams struct {
	UserID   string `json:"user_id"`
	TenantID string `json:"tenant_id"`
	Status   string `json:"status"`
}

func (q *Queries) UpdateUserTenantMembershipStatus(ctx context.Context, arg UpdateUserTenantMembershipStatusParams) (CoreUserTenantMembership, error) {
	row := q.db.QueryRow(ctx, updateUserTenantMembershipStatus, arg.UserID, arg.TenantID, arg.Status)
	var i CoreUserTenantMembership
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TenantID,
		&i.Role,
		&i.Status,
		&i.InvitedBy,
		&i.InvitedAt,
		&i.JoinedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
