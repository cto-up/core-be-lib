// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: email_verification.sql

package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createEmailVerificationToken = `-- name: CreateEmailVerificationToken :one
INSERT INTO core_email_verification_tokens (
  user_id, tenant_id, token, token_hash, expires_at
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING id, user_id, tenant_id, token, expires_at, used_at, created_at, updated_at
`

type CreateEmailVerificationTokenParams struct {
	UserID    string    `json:"user_id"`
	TenantID  string    `json:"tenant_id"`
	Token     string    `json:"token"`
	TokenHash []byte    `json:"token_hash"`
	ExpiresAt time.Time `json:"expires_at"`
}

type CreateEmailVerificationTokenRow struct {
	ID        uuid.UUID          `json:"id"`
	UserID    string             `json:"user_id"`
	TenantID  string             `json:"tenant_id"`
	Token     string             `json:"token"`
	ExpiresAt time.Time          `json:"expires_at"`
	UsedAt    pgtype.Timestamptz `json:"used_at"`
	CreatedAt time.Time          `json:"created_at"`
	UpdatedAt time.Time          `json:"updated_at"`
}

func (q *Queries) CreateEmailVerificationToken(ctx context.Context, arg CreateEmailVerificationTokenParams) (CreateEmailVerificationTokenRow, error) {
	row := q.db.QueryRow(ctx, createEmailVerificationToken,
		arg.UserID,
		arg.TenantID,
		arg.Token,
		arg.TokenHash,
		arg.ExpiresAt,
	)
	var i CreateEmailVerificationTokenRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TenantID,
		&i.Token,
		&i.ExpiresAt,
		&i.UsedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteEmailVerificationTokensByUserID = `-- name: DeleteEmailVerificationTokensByUserID :exec
DELETE FROM core_email_verification_tokens 
WHERE user_id = $1 AND tenant_id = $2
`

type DeleteEmailVerificationTokensByUserIDParams struct {
	UserID   string `json:"user_id"`
	TenantID string `json:"tenant_id"`
}

func (q *Queries) DeleteEmailVerificationTokensByUserID(ctx context.Context, arg DeleteEmailVerificationTokensByUserIDParams) error {
	_, err := q.db.Exec(ctx, deleteEmailVerificationTokensByUserID, arg.UserID, arg.TenantID)
	return err
}

const deleteExpiredEmailVerificationTokens = `-- name: DeleteExpiredEmailVerificationTokens :exec
DELETE FROM core_email_verification_tokens 
WHERE expires_at < clock_timestamp()
`

func (q *Queries) DeleteExpiredEmailVerificationTokens(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredEmailVerificationTokens)
	return err
}

const getEmailVerificationToken = `-- name: GetEmailVerificationToken :one
SELECT id, user_id, tenant_id, token, token_hash, expires_at, used_at, created_at, updated_at FROM core_email_verification_tokens
WHERE token = $1 
AND tenant_id = $2 
AND expires_at > clock_timestamp()
AND used_at IS NULL
LIMIT 1
`

type GetEmailVerificationTokenParams struct {
	Token    string `json:"token"`
	TenantID string `json:"tenant_id"`
}

func (q *Queries) GetEmailVerificationToken(ctx context.Context, arg GetEmailVerificationTokenParams) (CoreEmailVerificationToken, error) {
	row := q.db.QueryRow(ctx, getEmailVerificationToken, arg.Token, arg.TenantID)
	var i CoreEmailVerificationToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TenantID,
		&i.Token,
		&i.TokenHash,
		&i.ExpiresAt,
		&i.UsedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEmailVerificationTokenByUserID = `-- name: GetEmailVerificationTokenByUserID :one
SELECT id, user_id, tenant_id, token, token_hash, expires_at, used_at, created_at, updated_at FROM core_email_verification_tokens
WHERE user_id = $1 
AND tenant_id = $2
AND expires_at > clock_timestamp()
AND used_at IS NULL
ORDER BY created_at DESC
LIMIT 1
`

type GetEmailVerificationTokenByUserIDParams struct {
	UserID   string `json:"user_id"`
	TenantID string `json:"tenant_id"`
}

func (q *Queries) GetEmailVerificationTokenByUserID(ctx context.Context, arg GetEmailVerificationTokenByUserIDParams) (CoreEmailVerificationToken, error) {
	row := q.db.QueryRow(ctx, getEmailVerificationTokenByUserID, arg.UserID, arg.TenantID)
	var i CoreEmailVerificationToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TenantID,
		&i.Token,
		&i.TokenHash,
		&i.ExpiresAt,
		&i.UsedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const markEmailVerificationTokenAsUsed = `-- name: MarkEmailVerificationTokenAsUsed :exec
UPDATE core_email_verification_tokens 
SET used_at = clock_timestamp()
WHERE token = $1 AND tenant_id = $2
`

type MarkEmailVerificationTokenAsUsedParams struct {
	Token    string `json:"token"`
	TenantID string `json:"tenant_id"`
}

func (q *Queries) MarkEmailVerificationTokenAsUsed(ctx context.Context, arg MarkEmailVerificationTokenAsUsedParams) error {
	_, err := q.db.Exec(ctx, markEmailVerificationTokenAsUsed, arg.Token, arg.TenantID)
	return err
}
