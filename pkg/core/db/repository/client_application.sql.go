// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: client_application.sql

package repository

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createClientApplication = `-- name: CreateClientApplication :one
INSERT INTO core_client_applications (
  name, description, tenant_id, created_by
) VALUES (
  $1, $2, $4::varchar, $3
)
RETURNING id, name, description, tenant_id, active, created_by, created_at, updated_at, last_used_at
`

type CreateClientApplicationParams struct {
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	CreatedBy   string      `json:"created_by"`
	TenantID    pgtype.Text `json:"tenant_id"`
}

func (q *Queries) CreateClientApplication(ctx context.Context, arg CreateClientApplicationParams) (CoreClientApplication, error) {
	row := q.db.QueryRow(ctx, createClientApplication,
		arg.Name,
		arg.Description,
		arg.CreatedBy,
		arg.TenantID,
	)
	var i CoreClientApplication
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.TenantID,
		&i.Active,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsedAt,
	)
	return i, err
}

const deactivateClientApplication = `-- name: DeactivateClientApplication :one
UPDATE core_client_applications 
SET active = false
WHERE id = $1 AND (tenant_id = $2::varchar OR tenant_id IS NULL)
RETURNING id
`

type DeactivateClientApplicationParams struct {
	ID       uuid.UUID   `json:"id"`
	TenantID pgtype.Text `json:"tenant_id"`
}

func (q *Queries) DeactivateClientApplication(ctx context.Context, arg DeactivateClientApplicationParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, deactivateClientApplication, arg.ID, arg.TenantID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const deleteClientApplication = `-- name: DeleteClientApplication :one
DELETE FROM core_client_applications
WHERE id = $1 AND (tenant_id = $2::varchar OR tenant_id IS NULL)
RETURNING id
`

type DeleteClientApplicationParams struct {
	ID       uuid.UUID   `json:"id"`
	TenantID pgtype.Text `json:"tenant_id"`
}

func (q *Queries) DeleteClientApplication(ctx context.Context, arg DeleteClientApplicationParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, deleteClientApplication, arg.ID, arg.TenantID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getClientApplicationByID = `-- name: GetClientApplicationByID :one
SELECT id, name, description, tenant_id, active, created_by, created_at, updated_at, last_used_at FROM core_client_applications
WHERE id = $1 AND (tenant_id = $2::varchar OR tenant_id IS NULL)
LIMIT 1
`

type GetClientApplicationByIDParams struct {
	ID       uuid.UUID   `json:"id"`
	TenantID pgtype.Text `json:"tenant_id"`
}

func (q *Queries) GetClientApplicationByID(ctx context.Context, arg GetClientApplicationByIDParams) (CoreClientApplication, error) {
	row := q.db.QueryRow(ctx, getClientApplicationByID, arg.ID, arg.TenantID)
	var i CoreClientApplication
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.TenantID,
		&i.Active,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsedAt,
	)
	return i, err
}

const listClientApplications = `-- name: ListClientApplications :many
SELECT id, name, description, tenant_id, active, created_by, created_at, updated_at, last_used_at 
FROM core_client_applications
WHERE (tenant_id = $3::varchar OR tenant_id IS NULL)
  AND ($4::boolean OR active = true)
  AND (UPPER(name) LIKE UPPER($5) OR $5 IS NULL)
ORDER BY
  CASE WHEN $6::TEXT = 'name' AND $7::TEXT = 'asc' THEN name END ASC,
  CASE WHEN $6::TEXT = 'name' AND $7::TEXT != 'asc' THEN name END DESC,
  CASE WHEN $6::TEXT = 'created_at' AND $7::TEXT = 'asc' THEN created_at END ASC,
  CASE WHEN $6::TEXT = 'created_at' AND $7::TEXT != 'asc' THEN created_at END DESC
LIMIT $1
OFFSET $2
`

type ListClientApplicationsParams struct {
	Limit           int32       `json:"limit"`
	Offset          int32       `json:"offset"`
	TenantID        pgtype.Text `json:"tenant_id"`
	IncludeInactive pgtype.Bool `json:"include_inactive"`
	Like            interface{} `json:"like"`
	SortBy          string      `json:"sort_by"`
	Order           string      `json:"order"`
}

func (q *Queries) ListClientApplications(ctx context.Context, arg ListClientApplicationsParams) ([]CoreClientApplication, error) {
	rows, err := q.db.Query(ctx, listClientApplications,
		arg.Limit,
		arg.Offset,
		arg.TenantID,
		arg.IncludeInactive,
		arg.Like,
		arg.SortBy,
		arg.Order,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CoreClientApplication{}
	for rows.Next() {
		var i CoreClientApplication
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.TenantID,
			&i.Active,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastUsedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateClientApplication = `-- name: UpdateClientApplication :one
UPDATE core_client_applications
SET 
  name = $2,
  description = $3,
  active = $4
WHERE id = $1 AND (tenant_id = $5::varchar OR tenant_id IS NULL)
RETURNING id, name, description, tenant_id, active, created_by, created_at, updated_at, last_used_at
`

type UpdateClientApplicationParams struct {
	ID          uuid.UUID   `json:"id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	Active      bool        `json:"active"`
	TenantID    pgtype.Text `json:"tenant_id"`
}

func (q *Queries) UpdateClientApplication(ctx context.Context, arg UpdateClientApplicationParams) (CoreClientApplication, error) {
	row := q.db.QueryRow(ctx, updateClientApplication,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Active,
		arg.TenantID,
	)
	var i CoreClientApplication
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.TenantID,
		&i.Active,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsedAt,
	)
	return i, err
}

const updateClientApplicationLastUsed = `-- name: UpdateClientApplicationLastUsed :exec
UPDATE core_client_applications
SET last_used_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateClientApplicationLastUsed(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateClientApplicationLastUsed, id)
	return err
}
