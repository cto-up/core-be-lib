// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user_tenant_memberships.sql

package repository

import (
	"context"
	"time"

	subentity "ctoup.com/coreapp/pkg/shared/repository/subentity"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addRoleToUserTenantMembership = `-- name: AddRoleToUserTenantMembership :one
UPDATE core_user_tenant_memberships
SET roles = array_append(roles, $1::TEXT), updated_at = clock_timestamp()
WHERE user_id = $2 
  AND tenant_id = $3 
  AND NOT ($1::TEXT = ANY(roles))
RETURNING id, user_id, tenant_id, status, invited_by, invited_at, joined_at, created_at, updated_at, roles
`

type AddRoleToUserTenantMembershipParams struct {
	Role     string `json:"role"`
	UserID   string `json:"user_id"`
	TenantID string `json:"tenant_id"`
}

func (q *Queries) AddRoleToUserTenantMembership(ctx context.Context, arg AddRoleToUserTenantMembershipParams) (CoreUserTenantMembership, error) {
	row := q.db.QueryRow(ctx, addRoleToUserTenantMembership, arg.Role, arg.UserID, arg.TenantID)
	var i CoreUserTenantMembership
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TenantID,
		&i.Status,
		&i.InvitedBy,
		&i.InvitedAt,
		&i.JoinedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Roles,
	)
	return i, err
}

const checkUserHasTenantRole = `-- name: CheckUserHasTenantRole :one
SELECT EXISTS(
    SELECT 1 FROM core_user_tenant_memberships
    WHERE user_id = $1 
      AND tenant_id = $2 
      AND status = 'active' 
      AND $3::TEXT = ANY(roles)
) as has_role
`

type CheckUserHasTenantRoleParams struct {
	UserID   string `json:"user_id"`
	TenantID string `json:"tenant_id"`
	Role     string `json:"role"`
}

func (q *Queries) CheckUserHasTenantRole(ctx context.Context, arg CheckUserHasTenantRoleParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkUserHasTenantRole, arg.UserID, arg.TenantID, arg.Role)
	var has_role bool
	err := row.Scan(&has_role)
	return has_role, err
}

const checkUserTenantAccess = `-- name: CheckUserTenantAccess :one
SELECT EXISTS(
    SELECT 1 FROM core_user_tenant_memberships
    WHERE user_id = $1 AND tenant_id = $2 AND status = 'active'
) as has_access
`

type CheckUserTenantAccessParams struct {
	UserID   string `json:"user_id"`
	TenantID string `json:"tenant_id"`
}

func (q *Queries) CheckUserTenantAccess(ctx context.Context, arg CheckUserTenantAccessParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkUserTenantAccess, arg.UserID, arg.TenantID)
	var has_access bool
	err := row.Scan(&has_access)
	return has_access, err
}

const createUserTenantMembership = `-- name: CreateUserTenantMembership :one
INSERT INTO core_user_tenant_memberships (
    user_id,
    tenant_id,
    roles,
    status,
    invited_by,
    invited_at,
    joined_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, user_id, tenant_id, status, invited_by, invited_at, joined_at, created_at, updated_at, roles
`

type CreateUserTenantMembershipParams struct {
	UserID    string             `json:"user_id"`
	TenantID  string             `json:"tenant_id"`
	Roles     []string           `json:"roles"`
	Status    string             `json:"status"`
	InvitedBy pgtype.Text        `json:"invited_by"`
	InvitedAt pgtype.Timestamptz `json:"invited_at"`
	JoinedAt  pgtype.Timestamptz `json:"joined_at"`
}

func (q *Queries) CreateUserTenantMembership(ctx context.Context, arg CreateUserTenantMembershipParams) (CoreUserTenantMembership, error) {
	row := q.db.QueryRow(ctx, createUserTenantMembership,
		arg.UserID,
		arg.TenantID,
		arg.Roles,
		arg.Status,
		arg.InvitedBy,
		arg.InvitedAt,
		arg.JoinedAt,
	)
	var i CoreUserTenantMembership
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TenantID,
		&i.Status,
		&i.InvitedBy,
		&i.InvitedAt,
		&i.JoinedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Roles,
	)
	return i, err
}

const deleteUserTenantMembership = `-- name: DeleteUserTenantMembership :exec
DELETE FROM core_user_tenant_memberships
WHERE user_id = $1 AND tenant_id = $2
`

type DeleteUserTenantMembershipParams struct {
	UserID   string `json:"user_id"`
	TenantID string `json:"tenant_id"`
}

func (q *Queries) DeleteUserTenantMembership(ctx context.Context, arg DeleteUserTenantMembershipParams) error {
	_, err := q.db.Exec(ctx, deleteUserTenantMembership, arg.UserID, arg.TenantID)
	return err
}

const getUserTenantMembership = `-- name: GetUserTenantMembership :one
SELECT id, user_id, tenant_id, status, invited_by, invited_at, joined_at, created_at, updated_at, roles FROM core_user_tenant_memberships
WHERE user_id = $1 AND tenant_id = $2
LIMIT 1
`

type GetUserTenantMembershipParams struct {
	UserID   string `json:"user_id"`
	TenantID string `json:"tenant_id"`
}

func (q *Queries) GetUserTenantMembership(ctx context.Context, arg GetUserTenantMembershipParams) (CoreUserTenantMembership, error) {
	row := q.db.QueryRow(ctx, getUserTenantMembership, arg.UserID, arg.TenantID)
	var i CoreUserTenantMembership
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TenantID,
		&i.Status,
		&i.InvitedBy,
		&i.InvitedAt,
		&i.JoinedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Roles,
	)
	return i, err
}

const getUserTenantRoles = `-- name: GetUserTenantRoles :one
SELECT roles FROM core_user_tenant_memberships
WHERE user_id = $1 AND tenant_id = $2 AND status = 'active'
LIMIT 1
`

type GetUserTenantRolesParams struct {
	UserID   string `json:"user_id"`
	TenantID string `json:"tenant_id"`
}

func (q *Queries) GetUserTenantRoles(ctx context.Context, arg GetUserTenantRolesParams) ([]string, error) {
	row := q.db.QueryRow(ctx, getUserTenantRoles, arg.UserID, arg.TenantID)
	var roles []string
	err := row.Scan(&roles)
	return roles, err
}

const isUserMemberOfTenant = `-- name: IsUserMemberOfTenant :one
SELECT EXISTS(
    SELECT 1 FROM core_user_tenant_memberships
    WHERE user_id = $1 AND tenant_id = $2
) as is_member
`

type IsUserMemberOfTenantParams struct {
	UserID   string `json:"user_id"`
	TenantID string `json:"tenant_id"`
}

// Check if user is already a member of a specific tenant
func (q *Queries) IsUserMemberOfTenant(ctx context.Context, arg IsUserMemberOfTenantParams) (bool, error) {
	row := q.db.QueryRow(ctx, isUserMemberOfTenant, arg.UserID, arg.TenantID)
	var is_member bool
	err := row.Scan(&is_member)
	return is_member, err
}

const listPendingInvitations = `-- name: ListPendingInvitations :many
SELECT 
    utm.id, utm.user_id, utm.tenant_id, utm.status, utm.invited_by, utm.invited_at, utm.joined_at, utm.created_at, utm.updated_at, utm.roles,
    t.name as tenant_name,
    t.subdomain
FROM core_user_tenant_memberships utm
JOIN core_tenants t ON utm.tenant_id = t.tenant_id
WHERE utm.user_id = $1 AND utm.status = 'pending'
ORDER BY utm.invited_at DESC
`

type ListPendingInvitationsRow struct {
	ID         uuid.UUID          `json:"id"`
	UserID     string             `json:"user_id"`
	TenantID   string             `json:"tenant_id"`
	Status     string             `json:"status"`
	InvitedBy  pgtype.Text        `json:"invited_by"`
	InvitedAt  pgtype.Timestamptz `json:"invited_at"`
	JoinedAt   pgtype.Timestamptz `json:"joined_at"`
	CreatedAt  time.Time          `json:"created_at"`
	UpdatedAt  time.Time          `json:"updated_at"`
	Roles      []string           `json:"roles"`
	TenantName string             `json:"tenant_name"`
	Subdomain  string             `json:"subdomain"`
}

func (q *Queries) ListPendingInvitations(ctx context.Context, userID string) ([]ListPendingInvitationsRow, error) {
	rows, err := q.db.Query(ctx, listPendingInvitations, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPendingInvitationsRow{}
	for rows.Next() {
		var i ListPendingInvitationsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TenantID,
			&i.Status,
			&i.InvitedBy,
			&i.InvitedAt,
			&i.JoinedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Roles,
			&i.TenantName,
			&i.Subdomain,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTenantMembers = `-- name: ListTenantMembers :many
SELECT utm.id, utm.user_id, utm.tenant_id, utm.status, utm.invited_by, utm.invited_at, utm.joined_at, utm.created_at, utm.updated_at, utm.roles
FROM core_user_tenant_memberships utm
WHERE utm.tenant_id = $1 AND utm.status = $2
ORDER BY utm.created_at DESC
`

type ListTenantMembersParams struct {
	TenantID string `json:"tenant_id"`
	Status   string `json:"status"`
}

func (q *Queries) ListTenantMembers(ctx context.Context, arg ListTenantMembersParams) ([]CoreUserTenantMembership, error) {
	rows, err := q.db.Query(ctx, listTenantMembers, arg.TenantID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CoreUserTenantMembership{}
	for rows.Next() {
		var i CoreUserTenantMembership
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TenantID,
			&i.Status,
			&i.InvitedBy,
			&i.InvitedAt,
			&i.JoinedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Roles,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserTenantMemberships = `-- name: ListUserTenantMemberships :many
SELECT 
    utm.id, utm.user_id, utm.tenant_id, utm.status, utm.invited_by, utm.invited_at, utm.joined_at, utm.created_at, utm.updated_at, utm.roles,
    t.name as tenant_name,
    t.subdomain
FROM core_user_tenant_memberships utm
JOIN core_tenants t ON utm.tenant_id = t.tenant_id
WHERE utm.user_id = $1 AND utm.status = $2
ORDER BY utm.created_at DESC
`

type ListUserTenantMembershipsParams struct {
	UserID string `json:"user_id"`
	Status string `json:"status"`
}

type ListUserTenantMembershipsRow struct {
	ID         uuid.UUID          `json:"id"`
	UserID     string             `json:"user_id"`
	TenantID   string             `json:"tenant_id"`
	Status     string             `json:"status"`
	InvitedBy  pgtype.Text        `json:"invited_by"`
	InvitedAt  pgtype.Timestamptz `json:"invited_at"`
	JoinedAt   pgtype.Timestamptz `json:"joined_at"`
	CreatedAt  time.Time          `json:"created_at"`
	UpdatedAt  time.Time          `json:"updated_at"`
	Roles      []string           `json:"roles"`
	TenantName string             `json:"tenant_name"`
	Subdomain  string             `json:"subdomain"`
}

func (q *Queries) ListUserTenantMemberships(ctx context.Context, arg ListUserTenantMembershipsParams) ([]ListUserTenantMembershipsRow, error) {
	rows, err := q.db.Query(ctx, listUserTenantMemberships, arg.UserID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserTenantMembershipsRow{}
	for rows.Next() {
		var i ListUserTenantMembershipsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TenantID,
			&i.Status,
			&i.InvitedBy,
			&i.InvitedAt,
			&i.JoinedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Roles,
			&i.TenantName,
			&i.Subdomain,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersWithMemberships = `-- name: ListUsersWithMemberships :many
SELECT 
    u.id,
    u.email,
    u.profile,
    u.created_at,
    utm.roles,
    utm.status
FROM core_user_tenant_memberships utm
INNER JOIN core_users u ON utm.user_id = u.id
WHERE utm.tenant_id = $1 
  AND utm.status = 'active'
  AND (UPPER(u.email) LIKE UPPER($4) OR $4 IS NULL)
ORDER BY u.created_at
LIMIT $2
OFFSET $3
`

type ListUsersWithMembershipsParams struct {
	TenantID string      `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
	Like     interface{} `json:"like"`
}

type ListUsersWithMembershipsRow struct {
	ID        string                `json:"id"`
	Email     pgtype.Text           `json:"email"`
	Profile   subentity.UserProfile `json:"profile"`
	CreatedAt time.Time             `json:"created_at"`
	Roles     []string              `json:"roles"`
	Status    string                `json:"status"`
}

// List users for a tenant via memberships table (for Kratos)
// This joins with core_users to get user details
func (q *Queries) ListUsersWithMemberships(ctx context.Context, arg ListUsersWithMembershipsParams) ([]ListUsersWithMembershipsRow, error) {
	rows, err := q.db.Query(ctx, listUsersWithMemberships,
		arg.TenantID,
		arg.Limit,
		arg.Offset,
		arg.Like,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUsersWithMembershipsRow{}
	for rows.Next() {
		var i ListUsersWithMembershipsRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Profile,
			&i.CreatedAt,
			&i.Roles,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeRoleFromUserTenantMembership = `-- name: RemoveRoleFromUserTenantMembership :one
UPDATE core_user_tenant_memberships
SET roles = array_remove(roles, $1::TEXT), updated_at = clock_timestamp()
WHERE user_id = $2 
  AND tenant_id = $3 
  AND $1::TEXT = ANY(roles)
RETURNING id, user_id, tenant_id, status, invited_by, invited_at, joined_at, created_at, updated_at, roles
`

type RemoveRoleFromUserTenantMembershipParams struct {
	Role     string `json:"role"`
	UserID   string `json:"user_id"`
	TenantID string `json:"tenant_id"`
}

func (q *Queries) RemoveRoleFromUserTenantMembership(ctx context.Context, arg RemoveRoleFromUserTenantMembershipParams) (CoreUserTenantMembership, error) {
	row := q.db.QueryRow(ctx, removeRoleFromUserTenantMembership, arg.Role, arg.UserID, arg.TenantID)
	var i CoreUserTenantMembership
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TenantID,
		&i.Status,
		&i.InvitedBy,
		&i.InvitedAt,
		&i.JoinedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Roles,
	)
	return i, err
}

const removeUserFromTenant = `-- name: RemoveUserFromTenant :exec
DELETE FROM core_user_tenant_memberships
WHERE user_id = $1 AND tenant_id = $2
`

type RemoveUserFromTenantParams struct {
	UserID   string `json:"user_id"`
	TenantID string `json:"tenant_id"`
}

// Remove a user from a tenant (delete membership only)
// This is different from DeleteUserTenantMembership as it's more explicit about the action
func (q *Queries) RemoveUserFromTenant(ctx context.Context, arg RemoveUserFromTenantParams) error {
	_, err := q.db.Exec(ctx, removeUserFromTenant, arg.UserID, arg.TenantID)
	return err
}

const updateUserTenantMembershipJoinedAt = `-- name: UpdateUserTenantMembershipJoinedAt :one
UPDATE core_user_tenant_memberships
SET joined_at = $3, status = 'active', updated_at = clock_timestamp()
WHERE user_id = $1 AND tenant_id = $2
RETURNING id, user_id, tenant_id, status, invited_by, invited_at, joined_at, created_at, updated_at, roles
`

type UpdateUserTenantMembershipJoinedAtParams struct {
	UserID   string             `json:"user_id"`
	TenantID string             `json:"tenant_id"`
	JoinedAt pgtype.Timestamptz `json:"joined_at"`
}

func (q *Queries) UpdateUserTenantMembershipJoinedAt(ctx context.Context, arg UpdateUserTenantMembershipJoinedAtParams) (CoreUserTenantMembership, error) {
	row := q.db.QueryRow(ctx, updateUserTenantMembershipJoinedAt, arg.UserID, arg.TenantID, arg.JoinedAt)
	var i CoreUserTenantMembership
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TenantID,
		&i.Status,
		&i.InvitedBy,
		&i.InvitedAt,
		&i.JoinedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Roles,
	)
	return i, err
}

const updateUserTenantMembershipRoles = `-- name: UpdateUserTenantMembershipRoles :one
UPDATE core_user_tenant_memberships
SET roles = $3, updated_at = clock_timestamp()
WHERE user_id = $1 AND tenant_id = $2
RETURNING id, user_id, tenant_id, status, invited_by, invited_at, joined_at, created_at, updated_at, roles
`

type UpdateUserTenantMembershipRolesParams struct {
	UserID   string   `json:"user_id"`
	TenantID string   `json:"tenant_id"`
	Roles    []string `json:"roles"`
}

func (q *Queries) UpdateUserTenantMembershipRoles(ctx context.Context, arg UpdateUserTenantMembershipRolesParams) (CoreUserTenantMembership, error) {
	row := q.db.QueryRow(ctx, updateUserTenantMembershipRoles, arg.UserID, arg.TenantID, arg.Roles)
	var i CoreUserTenantMembership
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TenantID,
		&i.Status,
		&i.InvitedBy,
		&i.InvitedAt,
		&i.JoinedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Roles,
	)
	return i, err
}

const updateUserTenantMembershipStatus = `-- name: UpdateUserTenantMembershipStatus :one
UPDATE core_user_tenant_memberships
SET status = $3, updated_at = clock_timestamp()
WHERE user_id = $1 AND tenant_id = $2
RETURNING id, user_id, tenant_id, status, invited_by, invited_at, joined_at, created_at, updated_at, roles
`

type UpdateUserTenantMembershipStatusParams struct {
	UserID   string `json:"user_id"`
	TenantID string `json:"tenant_id"`
	Status   string `json:"status"`
}

func (q *Queries) UpdateUserTenantMembershipStatus(ctx context.Context, arg UpdateUserTenantMembershipStatusParams) (CoreUserTenantMembership, error) {
	row := q.db.QueryRow(ctx, updateUserTenantMembershipStatus, arg.UserID, arg.TenantID, arg.Status)
	var i CoreUserTenantMembership
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TenantID,
		&i.Status,
		&i.InvitedBy,
		&i.InvitedAt,
		&i.JoinedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Roles,
	)
	return i, err
}
