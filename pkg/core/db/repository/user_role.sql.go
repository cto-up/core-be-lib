// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: user_role.sql

package repository

import (
	"context"
	"time"

	subentity "ctoup.com/coreapp/pkg/shared/repository/subentity"
	"github.com/jackc/pgx/v5/pgtype"
)

const getUserRoleByID = `-- name: GetUserRoleByID :one
SELECT core_users.id, core_users.profile, core_users.email, core_users.created_at, core_users.tenant_id, JSON_AGG(core_roles.*) as core_roles
FROM core_users
LEFT JOIN core_roles ON core_users.core_roles @> ARRAY[core_roles.id]
WHERE core_users.id = $1 
AND core_users.tenant_id = $2::text
GROUP BY core_users.id
LIMIT 1
`

type GetUserRoleByIDParams struct {
	ID       string `json:"id"`
	TenantID string `json:"tenant_id"`
}

type GetUserRoleByIDRow struct {
	ID        string                `json:"id"`
	Profile   subentity.UserProfile `json:"profile"`
	Email     pgtype.Text           `json:"email"`
	CreatedAt time.Time             `json:"created_at"`
	TenantID  pgtype.Text           `json:"tenant_id"`
	CoreRoles []byte                `json:"core_roles"`
}

func (q *Queries) GetUserRoleByID(ctx context.Context, arg GetUserRoleByIDParams) (GetUserRoleByIDRow, error) {
	row := q.db.QueryRow(ctx, getUserRoleByID, arg.ID, arg.TenantID)
	var i GetUserRoleByIDRow
	err := row.Scan(
		&i.ID,
		&i.Profile,
		&i.Email,
		&i.CreatedAt,
		&i.TenantID,
		&i.CoreRoles,
	)
	return i, err
}

const listUsersRoles = `-- name: ListUsersRoles :many
SELECT core_users.id, core_users.profile, core_users.email, core_users.created_at, core_users.tenant_id, JSON_AGG(core_roles.*) as core_roles
FROM core_users
LEFT JOIN core_roles ON core_users.core_roles @> ARRAY[core_roles.id]
WHERE core_users.tenant_id = $3::text
AND (UPPER(core_users.profile->>'name') LIKE UPPER($4) OR $4 IS NULL)
GROUP BY core_users.id
ORDER BY core_users.created_at
LIMIT $1
OFFSET $2
`

type ListUsersRolesParams struct {
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
	TenantID string      `json:"tenant_id"`
	Like     interface{} `json:"like"`
}

type ListUsersRolesRow struct {
	ID        string                `json:"id"`
	Profile   subentity.UserProfile `json:"profile"`
	Email     pgtype.Text           `json:"email"`
	CreatedAt time.Time             `json:"created_at"`
	TenantID  pgtype.Text           `json:"tenant_id"`
	CoreRoles []byte                `json:"core_roles"`
}

func (q *Queries) ListUsersRoles(ctx context.Context, arg ListUsersRolesParams) ([]ListUsersRolesRow, error) {
	rows, err := q.db.Query(ctx, listUsersRoles,
		arg.Limit,
		arg.Offset,
		arg.TenantID,
		arg.Like,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUsersRolesRow{}
	for rows.Next() {
		var i ListUsersRolesRow
		if err := rows.Scan(
			&i.ID,
			&i.Profile,
			&i.Email,
			&i.CreatedAt,
			&i.TenantID,
			&i.CoreRoles,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
